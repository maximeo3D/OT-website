/**
 * @license bippy
 *
 * Copyright (c) Aiden Bai
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import{BIPPY_INSTRUMENTATION_STRING$1 as e,getRDTHook$1 as t,hasRDTHook$1 as n,isReactRefresh$1 as r,isRealReactDevtools$1 as i}from"./rdt-hook-CrcWl4lP.js";const a=0,o=1,s=3,c=5,l=6,u=7,d=9,f=11,p=13,m=14,h=15,ee=16,g=18,te=19,_=22,v=23,y=26,b=27,ne=28,re=30,x=60111,S=`Symbol(react.element)`,C=`Symbol(react.transitional.element)`,w=`Symbol(react.concurrent_mode)`,T=`Symbol(react.async_mode)`,E=1,ie=2,ae=4096,oe=4,D=8,se=16,ce=32,le=1024,ue=8192,O=ie|oe|se|ce|ae|ue|le,de=e=>typeof e==`object`&&!!e&&`$$typeof`in e&&[S,C].includes(String(e.$$typeof)),fe=e=>typeof e==`object`&&!!e&&`tag`in e&&`stateNode`in e&&`return`in e&&`child`in e&&`sibling`in e&&`flags`in e,k=e=>{switch(e.tag){case c:case y:case b:return!0;default:return typeof e.type==`string`}},pe=e=>{switch(e.tag){case o:case f:case a:case m:case h:return!0;default:return!1}},me=e=>!e||typeof e!=`object`?!0:`pendingProps`in e&&!(`containerInfo`in e),he=(e,t)=>e===t||e.alternate===t||t.alternate===e,ge=(e,t)=>{try{let n=e.dependencies,r=e.alternate?.dependencies;if(!n||!r||typeof n!=`object`||!(`firstContext`in n)||typeof r!=`object`||!(`firstContext`in r))return!1;let i=n.firstContext,a=r.firstContext;for(;i&&typeof i==`object`&&`memoizedValue`in i||a&&typeof a==`object`&&`memoizedValue`in a;){if(t(i,a)===!0)return!0;i=i?.next,a=a?.next}}catch{}return!1},_e=(e,t)=>{try{let n=e.memoizedState,r=e.alternate?.memoizedState;for(;n||r;){if(t(n,r)===!0)return!0;n=n?.next,r=r?.next}}catch{}return!1},ve=(e,t)=>{try{let n=e.memoizedProps,r=e.alternate?.memoizedProps||{},i=new Set([...Object.keys(n),...Object.keys(r)]);for(let e of i){let i=r?.[e],a=n?.[e];if(t(e,a,i)===!0)return!0}}catch{}return!1},A=e=>{let t=e.memoizedProps,n=e.alternate?.memoizedProps||{},r=e.flags??e.effectTag??0;switch(e.tag){case o:case d:case f:case a:case m:case h:return(r&E)===E;default:return e.alternate?n!==t||e.alternate.memoizedState!==e.memoizedState||e.alternate.ref!==e.ref:!0}},j=e=>(e.flags&(O|D))!==0||(e.subtreeFlags&(O|D))!==0,ye=e=>{let t=[],n=[e];for(;n.length;){let e=n.pop();e&&(k(e)&&j(e)&&A(e)&&t.push(e),e.child&&n.push(e.child),e.sibling&&n.push(e.sibling))}return t},be=e=>{let t=[],n=e;for(;n.return;)t.push(n),n=n.return;return t},M=e=>{switch(e.tag){case g:return!0;case u:case l:case v:case _:return!0;case s:return!1;default:{let t=typeof e.type==`object`&&e.type!==null?e.type.$$typeof:e.type,n=typeof t==`symbol`?t.toString():t;switch(n){case x:case w:case T:return!0;default:return!1}}}},xe=(e,t=!1)=>{let n=N(e,k,t);return n||=N(e,k,!t),n},Se=e=>{let t=[],n=[];for(k(e)?t.push(e):e.child&&n.push(e.child);n.length;){let e=n.pop();if(!e)break;k(e)?t.push(e):e.child&&n.push(e.child),e.sibling&&n.push(e.sibling)}return t};function N(e,t,n=!1){if(!e)return null;let r=t(e);if(r instanceof Promise)return(async()=>{if(await r===!0)return e;let i=n?e.return:e.child;for(;i;){let e=await F(i,t,n);if(e)return e;i=n?null:i.sibling}return null})();if(r===!0)return e;let i=n?e.return:e.child;for(;i;){let e=P(i,t,n);if(e)return e;i=n?null:i.sibling}return null}const P=(e,t,n=!1)=>{if(!e)return null;if(t(e)===!0)return e;let r=n?e.return:e.child;for(;r;){let e=P(r,t,n);if(e)return e;r=n?null:r.sibling}return null},F=async(e,t,n=!1)=>{if(!e)return null;if(await t(e)===!0)return e;let r=n?e.return:e.child;for(;r;){let e=await F(r,t,n);if(e)return e;r=n?null:r.sibling}return null},Ce=e=>{let t=e?.actualDuration??0,n=t,r=e?.child??null;for(;t>0&&r!=null;)n-=r.actualDuration??0,r=r.sibling;return{selfTime:n,totalTime:t}},we=e=>!!e.updateQueue?.memoCache,I=e=>{let t=e;return typeof t==`function`?t:typeof t==`object`&&t?I(t.type||t.render):null},Te=e=>{let t=e;if(typeof t==`string`)return t;if(typeof t!=`function`&&!(typeof t==`object`&&t))return null;let n=t.displayName||t.name||null;if(n)return n;let r=I(t);return r&&(r.displayName||r.name)||null},L=e=>{try{if(typeof e.version==`string`&&e.bundleType>0)return`development`}catch{}return`production`},Ee=()=>{let e=t();return!!e._instrumentationIsActive||i()||r()},De=e=>{let t=e.alternate;if(!t)return e;if(t.actualStartTime&&e.actualStartTime)return t.actualStartTime>e.actualStartTime?t:e;for(let t of $){let n=N(t.current,t=>{if(t===e)return!0});if(n)return n}return e};let R=0;const z=new WeakMap,B=(e,t=R++)=>{z.set(e,t)},V=e=>{let t=z.get(e);return!t&&e.alternate&&(t=z.get(e.alternate)),t||(t=R++,B(e,t)),t},H=(e,t,n)=>{let r=t;for(;r!=null;){z.has(r)||V(r);let t=!M(r);if(t&&A(r)&&e(r,`mount`),r.tag===p){let t=r.memoizedState!==null;if(t){let t=r.child,n=t?t.sibling:null;if(n){let t=n.child;t!==null&&H(e,t,!1)}}else{let t=null,n=_===-1;n?t=r.child:r.child!==null&&(t=r.child.child),t!==null&&H(e,t,!1)}}else r.child!=null&&H(e,r.child,!0);r=n?r.sibling:null}},U=(e,t,n,r)=>{if(z.has(t)||V(t),!n)return;z.has(n)||V(n);let i=t.tag===p,a=!M(t);a&&A(t)&&e(t,`update`);let o=i&&n.memoizedState!==null,s=i&&t.memoizedState!==null;if(o&&s){let r=t.child?.sibling??null,i=n.child?.sibling??null;r!==null&&i!==null&&U(e,r,i,t)}else if(o&&!s){let n=t.child;n!==null&&H(e,n,!0)}else if(!o&&s){G(e,n);let r=t.child?.sibling??null;r!==null&&H(e,r,!0)}else if(t.child!==n.child){let n=t.child;for(;n;){if(n.alternate){let i=n.alternate;U(e,n,i,a?t:r)}else H(e,n,!1);n=n.sibling}}},W=(e,t)=>{let n=t.tag===s;(n||!M(t))&&e(t,`unmount`)},G=(e,t)=>{let n=t.tag===p&&t.memoizedState!==null,r=t.child;if(n){let e=t.child,n=e?.sibling??null;r=n?.child??null}for(;r!==null;)r.return!==null&&(W(e,r),G(e,r)),r=r.sibling};let Oe=0;const K=new WeakMap,ke=(e,t)=>{let n=`current`in e?e.current:e,r=K.get(e);r||(r={id:Oe++,prevFiber:null},K.set(e,r));let{prevFiber:i}=r;if(!n)W(t,n);else if(i!==null){let e=i&&i.memoizedState!=null&&i.memoizedState.element!=null&&i.memoizedState.isDehydrated!==!0,r=n.memoizedState!=null&&n.memoizedState.element!=null&&n.memoizedState.isDehydrated!==!0;!e&&r?H(t,n,!1):e&&r?U(t,n,n.alternate,null):e&&!r&&W(t,n)}else H(t,n,!0);r.prevFiber=n};let q=null,J=null,Y=null;const X=()=>{if(!n())return null;let e=t();if(!e?.renderers)return null;if(q||J||Y)return{overrideContext:Y,overrideHookState:J,overrideProps:q};for(let[,t]of Array.from(e.renderers))try{if(J){let e=J;J=(n,r,i,a)=>{let o=n.memoizedState;for(let e=0;e<Number(r)&&o?.next;e++)o=o.next;if(o?.queue){let e=o.queue;if(Z(e)&&`dispatch`in e){let t=e.dispatch;t(a);return}}e(n,r,i,a),t.overrideHookState?.(n,r,i,a)}}else t.overrideHookState&&(J=t.overrideHookState);if(q){let e=q;q=(n,r,i)=>{e(n,r,i),t.overrideProps?.(n,r,i)}}else t.overrideProps&&(q=t.overrideProps);Y=(e,t,n,r)=>{let i=e;for(;i;){let e=i.type;if(e===t||e?.Provider===t){q&&(q(i,[`value`,...n],r),i.alternate&&q(i.alternate,[`value`,...n],r));break}i=i.return}}}catch{}},Z=e=>Object.prototype.toString.call(e)===`[object Object]`&&(Object.getPrototypeOf(e)===Object.prototype||Object.getPrototypeOf(e)===null),Q=(e,t=[])=>{if(!Z(e))return[{path:t,value:e}];let n=[];for(let r in e){let i=e[r],a=t.concat(r);Z(i)?n.push(...Q(i,a)):n.push({path:a,value:i})}return n},Ae=(e,t)=>{X();let n=Q(t);for(let{path:t,value:r}of n)try{q?.(e,t,r)}catch{}},je=(e,t,n)=>{X();let r=String(t);if(Z(n)){let t=Q(n);for(let{path:n,value:i}of t)try{J?.(e,r,n,i)}catch{}}else try{J?.(e,r,[],n)}catch{}},Me=(e,t,n)=>{if(X(),Z(n)){let r=Q(n);for(let{path:n,value:i}of r)try{Y?.(e,t,n,i)}catch{}}else try{Y?.(e,t,[],n)}catch{}},Ne=n=>{let r=t(n.onActive);r._instrumentationSource=n.name??e;let i=r.onCommitFiberRoot;if(n.onCommitFiberRoot){let e=(t,r,a)=>{i!==e&&(i?.(t,r,a),n.onCommitFiberRoot?.(t,r,a))};r.onCommitFiberRoot=e}let a=r.onCommitFiberUnmount;if(n.onCommitFiberUnmount){let e=(t,i)=>{r.onCommitFiberUnmount===e&&(a?.(t,i),n.onCommitFiberUnmount?.(t,i))};r.onCommitFiberUnmount=e}let o=r.onPostCommitFiberRoot;if(n.onPostCommitFiberRoot){let e=(t,i)=>{r.onPostCommitFiberRoot===e&&(o?.(t,i),n.onPostCommitFiberRoot?.(t,i))};r.onPostCommitFiberRoot=e}return r},Pe=e=>{let n=t();for(let t of n.renderers.values())try{let n=t.findFiberByHostInstance?.(e);if(n)return n}catch{}if(typeof e==`object`&&e){if(`_reactRootContainer`in e)return e._reactRootContainer?._internalRoot?.current?.child;for(let t in e)if(t.startsWith(`__reactContainer$`)||t.startsWith(`__reactInternalInstance$`)||t.startsWith(`__reactFiber`))return e[t]||null}return null},Fe=Error(),$=new Set,Ie=(e,a={})=>{let o=e.onActive,s=n(),c=i(),l=r(),u,d=!a.isProduction;return e.onActive=()=>{clearTimeout(u);let n=!0;try{let e=t();for(let t of e.renderers.values()){let[e]=t.version.split(`.`);Number(e)<(a.minReactMajorVersion??17)&&(n=!1);let r=L(t);r===`development`?d=!0:a.dangerouslyRunInProduction||(n=!1)}}catch(e){a.onError?.(e)}if(!n){e.onCommitFiberRoot=void 0,e.onCommitFiberUnmount=void 0,e.onPostCommitFiberRoot=void 0,e.onActive=void 0;return}o?.();try{let t=e.onCommitFiberRoot;t&&(e.onCommitFiberRoot=(e,n,r)=>{$.has(n)||$.add(n);try{t(e,n,r)}catch(e){a.onError?.(e)}});let n=e.onCommitFiberUnmount;n&&(e.onCommitFiberUnmount=(e,t)=>{try{n(e,t)}catch(e){a.onError?.(e)}});let r=e.onPostCommitFiberRoot;r&&(e.onPostCommitFiberRoot=(e,t)=>{try{r(e,t)}catch(e){a.onError?.(e)}})}catch(e){a.onError?.(e)}},!s&&!c&&!l&&(u=setTimeout(()=>{d&&a.onError?.(Fe),stop()},a.installCheckTimeout??100)),e};export{ne as ActivityComponentTag,x as CONCURRENT_MODE_NUMBER,w as CONCURRENT_MODE_SYMBOL_STRING,o as ClassComponentTag,d as ContextConsumerTag,T as DEPRECATED_ASYNC_MODE_SYMBOL_STRING,g as DehydratedSuspenseComponentTag,S as ELEMENT_TYPE_SYMBOL_STRING,f as ForwardRefTag,u as FragmentTag,a as FunctionComponentTag,c as HostComponentTag,y as HostHoistableTag,s as HostRootTag,b as HostSingletonTag,l as HostTextTag,Fe as INSTALL_ERROR,ee as LazyComponentTag,v as LegacyHiddenComponentTag,m as MemoComponentTag,_ as OffscreenComponentTag,h as SimpleMemoComponentTag,p as SuspenseComponentTag,te as SuspenseListComponentTag,C as TRANSITIONAL_ELEMENT_TYPE_SYMBOL_STRING,re as ViewTransitionComponentTag,$ as _fiberRoots,he as areFiberEqual,L as detectReactBuildType,j as didFiberCommit,A as didFiberRender,z as fiberIdMap,Te as getDisplayName,Pe as getFiberFromHostInstance,V as getFiberId,be as getFiberStack,De as getLatestFiber,ye as getMutatedHostFibers,xe as getNearestHostFiber,Se as getNearestHostFibers,Ce as getTimings,I as getType,we as hasMemoCache,X as injectOverrideMethods,Ne as instrument,pe as isCompositeFiber,me as isFiber,k as isHostFiber,Ee as isInstrumentationActive,de as isValidElement,fe as isValidFiber,H as mountFiberRecursively,Me as overrideContext,je as overrideHookState,Ae as overrideProps,Ie as secure,B as setFiberId,M as shouldFilterFiber,ge as traverseContexts,N as traverseFiber,F as traverseFiberAsync,P as traverseFiberSync,ve as traverseProps,ke as traverseRenderedFibers,_e as traverseState,W as unmountFiber,G as unmountFiberChildrenRecursively,U as updateFiberRecursively};