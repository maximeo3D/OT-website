import { Fiber } from "./core-CEUgwvkw.cjs";
import "./install-hook-only-DxmHBPLt.cjs";
import "./index-D_TYgLX3.cjs";
import { SourceMapSegment } from "@jridgewell/sourcemap-codec";

//#region src/source/component-stack.d.ts
declare const describeDebugInfoFrame: (name: string, env?: string) => string;
declare const describeFiber: (fiber: Fiber, childFiber: Fiber | null) => string;
/**
 * react 19 introduces the _debugStack property, which we can use to grab the stack.
 * however, for versions that don't have this property, we need to construct
 * a "fake" version of the owner stack
 */
declare const getFallbackOwnerStack: (thisFiber: Fiber) => string;
/**
 * takes Error.stack and formats it to only the React owner stack
 *
 * before:
 * ```
 * Error: react-stack-top-frame
 * at fakeJSXCallSite (http://localhost:3000/_next/static/chunks/<chunk-name>._.js:17665:16)
 * at TodoItem (rsc://React/Server/file:///path/to/project/.next/server/chunks/ssr/<chunk-name>._.js)
 * at react-stack-bottom-frame (http://localhost:3000/_next/static/chunks/<chunk-name>._.js:17984:89)
 * ```
 *
 * after:
 * ```
 * at TodoItem (rsc://React/Server/file:///path/to/project/.next/server/chunks/ssr/<chunk-name>._.js)
 * ```
 *
 * @see https://github.com/facebook/react/blob/main/packages/react-devtools-shared/src/backend/shared/DevToolsOwnerStack.js#L12
 */
declare const formatOwnerStack: (stack: string) => string;

//#endregion
//#region src/source/types.d.ts
interface FiberSource {
  columnNumber?: number;
  fileName: string;
  lineNumber?: number;
  functionName?: string;
}

//#endregion
//#region src/source/get-source.d.ts
declare const hasDebugStack: (fiber: Fiber) => fiber is Fiber & {
  _debugStack: NonNullable<Fiber["_debugStack"]>;
};
declare const hasDebugSource: (fiber: Fiber) => fiber is Fiber & {
  _debugSource: NonNullable<Fiber["_debugSource"]>;
};
/**
 * Returns the source of where the component is used. Available only in dev, for composite {@link Fiber}s.
 *
 * @example
 * ```ts
 * function Parent() {
 *   const data = useData();
 *   return <Child name={data.name} />; // <-- captures THIS line
 * }
 *
 * function Child({ name }) {
 *   return <div>{name}</div>;
 * }
 *
 * const source = await getSource(fiber);
 * console.log(source.fileName, source.lineNumber);
 * ```
 */
declare const getSource: (fiber: Fiber, cache?: boolean, fetchFn?: (url: string) => Promise<Response>) => Promise<FiberSource | null>;
declare const getOwnerStack: (fiber: Fiber) => string;
declare const getSourceFromStack: (ownerStack: string, cache?: boolean, fetchFn?: (url: string) => Promise<Response>) => Promise<FiberSource | null>;
declare const getSourcesFromStack: (ownerStack: string, slice?: number, cache?: boolean, fetchFn?: (url: string) => Promise<Response>) => Promise<FiberSource[] | null>;
declare const normalizeFileName: (fileName: string) => string;
declare const isSourceFile: (fileName: string) => boolean;
/**
 * Returns the nearest available source location for a {@link Fiber}. Traverses up the fiber tree to find the nearest composite fiber with a valid source file, falling back to stack parsing if needed.
 *
 * @example
 * ```ts
 * const source = await getNearestValidSource(hostFiber);
 * if (source) {
 *   console.log(`${source.fileName}:${source.lineNumber}:${source.columnNumber}`);
 * }
 * ```
 */
declare const getNearestValidSource: (fiber: Fiber, cache?: boolean, fetchFn?: (url: string) => Promise<Response>) => Promise<FiberSource | null>;
/**
 * Returns the source location from a DOM node or element by finding its associated {@link Fiber} and traversing to the nearest available source.
 *
 * @example
 * ```ts
 * const element = document.querySelector('.my-component');
 * const source = await getSourceFromHostInstance(element);
 * if (source) {
 *   console.log(`Component defined at ${source.fileName}:${source.lineNumber}`);
 * }
 * ```
 */
declare const getSourceFromHostInstance: (target: Node | Element, cache?: boolean, fetchFn?: (url: string) => Promise<Response>) => Promise<FiberSource | null>;

//#endregion
//#region src/source/symbolication.d.ts
interface DecodedSourceMapSection {
  map: {
    file?: string;
    mappings: SourceMapSegment[][];
    names?: string[];
    sourceRoot?: string;
    sources: string[];
    sourcesContent?: string[];
    version: 3;
  };
  offset: {
    column: number;
    line: number;
  };
}
interface IndexSourceMap {
  file?: string;
  sections: Array<{
    map: StandardSourceMap;
    offset: {
      column: number;
      line: number;
    };
  }>;
  version: 3;
}
type RawSourceMap = IndexSourceMap | StandardSourceMap;
interface SourceMap {
  file?: string;
  mappings: SourceMapSegment[][];
  names?: string[];
  sections?: DecodedSourceMapSection[];
  sourceRoot?: string;
  sources: string[];
  sourcesContent?: string[];
  version: 3;
}
interface StandardSourceMap {
  file?: string;
  mappings: string;
  names?: string[];
  sourceRoot?: string;
  sources: string[];
  sourcesContent?: string[];
  version: 3;
}
declare const sourceMapCache: Map<string, SourceMap | WeakRef<SourceMap> | null>;
declare const getSourceFromSourceMap: (sourceMap: SourceMap, line: number, column: number) => FiberSource | null;
declare const getSourceMapImpl: (bundleUrl: string, fetchFn?: (url: string) => Promise<Response>) => Promise<null | SourceMap>;
declare const getSourceMap: (file: string, useCache?: boolean, fetchFn?: (url: string) => Promise<Response>) => Promise<null | SourceMap>;

//#endregion
//#region src/source/parse-stack.d.ts
interface StackFrame {
  args?: unknown[];
  columnNumber?: number;
  lineNumber?: number;
  fileName?: string;
  functionName?: string;
  source?: string;
}
interface StackFrameLite {
  function?: string;
  args?: unknown[];
  file?: string;
  col?: number;
  line?: number;
  raw?: string;
}
interface ParseOptions {
  slice?: number | [number, number];
  allowEmpty?: boolean;
  includeInElement?: boolean;
}
declare const parseStack: (stackString: string, options?: ParseOptions) => StackFrameLite[];
declare const extractLocation: (urlLike: string) => [string, string | undefined, string | undefined];
declare const parseV8OrIE: (error: Error, options?: ParseOptions) => StackFrameLite[];
declare const parseV8OrIeString: (stack: string, options?: ParseOptions) => StackFrameLite[];
declare const parseFFOrSafari: (error: Error, options?: ParseOptions) => StackFrameLite[];
declare const parseFFOrSafariString: (stack: string, options?: ParseOptions) => StackFrameLite[];
declare const parseOpera: (error: Error, options?: ParseOptions) => StackFrameLite[];
declare const parseOpera9: (error: Error, options?: ParseOptions) => StackFrameLite[];
declare const parseOpera10: (error: Error, options?: ParseOptions) => StackFrameLite[];
declare const parseOpera11: (error: Error, options?: ParseOptions) => StackFrameLite[];

//#endregion
//#region src/source/get-display-name-from-source.d.ts
declare const getDisplayNameFromSource: (fiber: Fiber, cache?: boolean, fetchFn?: (url: string) => Promise<Response>) => Promise<string | null>;

//#endregion
export { DecodedSourceMapSection, FiberSource, IndexSourceMap, ParseOptions, RawSourceMap, SourceMap, StackFrame, StackFrameLite, StandardSourceMap, describeDebugInfoFrame, describeFiber, extractLocation, formatOwnerStack, getDisplayNameFromSource, getFallbackOwnerStack, getNearestValidSource, getOwnerStack, getSource, getSourceFromHostInstance, getSourceFromSourceMap, getSourceFromStack, getSourceMap, getSourceMapImpl, getSourcesFromStack, hasDebugSource, hasDebugStack, isSourceFile, normalizeFileName, parseFFOrSafari, parseFFOrSafariString, parseOpera, parseOpera10, parseOpera11, parseOpera9, parseStack, parseV8OrIE, parseV8OrIeString, sourceMapCache };