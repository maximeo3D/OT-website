'use strict';

/**
 * @license MIT
 *
 * Copyright (c) 2025 Aiden Bai
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var IS_DEV = false;
var equalFn = (a3, b3) => a3 === b3;
var $TRACK = Symbol("solid-track");
var signalOptions = {
  equals: equalFn
};
var runEffects = runQueue;
var STALE = 1;
var PENDING = 2;
var UNOWNED = {
  owned: null,
  cleanups: null,
  context: null,
  owner: null
};
var Owner = null;
var Transition = null;
var ExternalSourceConfig = null;
var Listener = null;
var Updates = null;
var Effects = null;
var ExecCount = 0;
function createRoot(fn, detachedOwner) {
  const listener = Listener, owner = Owner, unowned = fn.length === 0, current = detachedOwner === void 0 ? owner : detachedOwner, root = unowned ? UNOWNED : {
    owned: null,
    cleanups: null,
    context: current ? current.context : null,
    owner: current
  }, updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));
  Owner = root;
  Listener = null;
  try {
    return runUpdates(updateFn, true);
  } finally {
    Listener = listener;
    Owner = owner;
  }
}
function createSignal(value, options) {
  options = options ? Object.assign({}, signalOptions, options) : signalOptions;
  const s3 = {
    value,
    observers: null,
    observerSlots: null,
    comparator: options.equals || void 0
  };
  const setter = (value2) => {
    if (typeof value2 === "function") {
      value2 = value2(s3.value);
    }
    return writeSignal(s3, value2);
  };
  return [readSignal.bind(s3), setter];
}
function createRenderEffect(fn, value, options) {
  const c3 = createComputation(fn, value, false, STALE);
  updateComputation(c3);
}
function createEffect(fn, value, options) {
  runEffects = runUserEffects;
  const c3 = createComputation(fn, value, false, STALE);
  c3.user = true;
  Effects ? Effects.push(c3) : updateComputation(c3);
}
function createMemo(fn, value, options) {
  options = options ? Object.assign({}, signalOptions, options) : signalOptions;
  const c3 = createComputation(fn, value, true, 0);
  c3.observers = null;
  c3.observerSlots = null;
  c3.comparator = options.equals || void 0;
  updateComputation(c3);
  return readSignal.bind(c3);
}
function untrack(fn) {
  if (Listener === null) return fn();
  const listener = Listener;
  Listener = null;
  try {
    if (ExternalSourceConfig) ;
    return fn();
  } finally {
    Listener = listener;
  }
}
function on(deps, fn, options) {
  const isArray = Array.isArray(deps);
  let prevInput;
  return (prevValue) => {
    let input;
    if (isArray) {
      input = Array(deps.length);
      for (let i2 = 0; i2 < deps.length; i2++) input[i2] = deps[i2]();
    } else input = deps();
    const result = untrack(() => fn(input, prevInput, prevValue));
    prevInput = input;
    return result;
  };
}
function onMount(fn) {
  createEffect(() => untrack(fn));
}
function onCleanup(fn) {
  if (Owner === null) ;
  else if (Owner.cleanups === null) Owner.cleanups = [fn];
  else Owner.cleanups.push(fn);
  return fn;
}
function readSignal() {
  if (this.sources && (this.state)) {
    if ((this.state) === STALE) updateComputation(this);
    else {
      const updates = Updates;
      Updates = null;
      runUpdates(() => lookUpstream(this), false);
      Updates = updates;
    }
  }
  if (Listener) {
    const sSlot = this.observers ? this.observers.length : 0;
    if (!Listener.sources) {
      Listener.sources = [this];
      Listener.sourceSlots = [sSlot];
    } else {
      Listener.sources.push(this);
      Listener.sourceSlots.push(sSlot);
    }
    if (!this.observers) {
      this.observers = [Listener];
      this.observerSlots = [Listener.sources.length - 1];
    } else {
      this.observers.push(Listener);
      this.observerSlots.push(Listener.sources.length - 1);
    }
  }
  return this.value;
}
function writeSignal(node, value, isComp) {
  let current = node.value;
  if (!node.comparator || !node.comparator(current, value)) {
    node.value = value;
    if (node.observers && node.observers.length) {
      runUpdates(() => {
        for (let i2 = 0; i2 < node.observers.length; i2 += 1) {
          const o3 = node.observers[i2];
          const TransitionRunning = Transition && Transition.running;
          if (TransitionRunning && Transition.disposed.has(o3)) ;
          if (TransitionRunning ? !o3.tState : !o3.state) {
            if (o3.pure) Updates.push(o3);
            else Effects.push(o3);
            if (o3.observers) markDownstream(o3);
          }
          if (!TransitionRunning) o3.state = STALE;
        }
        if (Updates.length > 1e6) {
          Updates = [];
          if (IS_DEV) ;
          throw new Error();
        }
      }, false);
    }
  }
  return value;
}
function updateComputation(node) {
  if (!node.fn) return;
  cleanNode(node);
  const time = ExecCount;
  runComputation(node, node.value, time);
}
function runComputation(node, value, time) {
  let nextValue;
  const owner = Owner, listener = Listener;
  Listener = Owner = node;
  try {
    nextValue = node.fn(value);
  } catch (err) {
    if (node.pure) {
      {
        node.state = STALE;
        node.owned && node.owned.forEach(cleanNode);
        node.owned = null;
      }
    }
    node.updatedAt = time + 1;
    return handleError(err);
  } finally {
    Listener = listener;
    Owner = owner;
  }
  if (!node.updatedAt || node.updatedAt <= time) {
    if (node.updatedAt != null && "observers" in node) {
      writeSignal(node, nextValue);
    } else node.value = nextValue;
    node.updatedAt = time;
  }
}
function createComputation(fn, init2, pure, state = STALE, options) {
  const c3 = {
    fn,
    state,
    updatedAt: null,
    owned: null,
    sources: null,
    sourceSlots: null,
    cleanups: null,
    value: init2,
    owner: Owner,
    context: Owner ? Owner.context : null,
    pure
  };
  if (Owner === null) ;
  else if (Owner !== UNOWNED) {
    {
      if (!Owner.owned) Owner.owned = [c3];
      else Owner.owned.push(c3);
    }
  }
  return c3;
}
function runTop(node) {
  if ((node.state) === 0) return;
  if ((node.state) === PENDING) return lookUpstream(node);
  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);
  const ancestors = [node];
  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
    if (node.state) ancestors.push(node);
  }
  for (let i2 = ancestors.length - 1; i2 >= 0; i2--) {
    node = ancestors[i2];
    if ((node.state) === STALE) {
      updateComputation(node);
    } else if ((node.state) === PENDING) {
      const updates = Updates;
      Updates = null;
      runUpdates(() => lookUpstream(node, ancestors[0]), false);
      Updates = updates;
    }
  }
}
function runUpdates(fn, init2) {
  if (Updates) return fn();
  let wait = false;
  if (!init2) Updates = [];
  if (Effects) wait = true;
  else Effects = [];
  ExecCount++;
  try {
    const res = fn();
    completeUpdates(wait);
    return res;
  } catch (err) {
    if (!wait) Effects = null;
    Updates = null;
    handleError(err);
  }
}
function completeUpdates(wait) {
  if (Updates) {
    runQueue(Updates);
    Updates = null;
  }
  if (wait) return;
  const e2 = Effects;
  Effects = null;
  if (e2.length) runUpdates(() => runEffects(e2), false);
}
function runQueue(queue) {
  for (let i2 = 0; i2 < queue.length; i2++) runTop(queue[i2]);
}
function runUserEffects(queue) {
  let i2, userLength = 0;
  for (i2 = 0; i2 < queue.length; i2++) {
    const e2 = queue[i2];
    if (!e2.user) runTop(e2);
    else queue[userLength++] = e2;
  }
  for (i2 = 0; i2 < userLength; i2++) runTop(queue[i2]);
}
function lookUpstream(node, ignore) {
  node.state = 0;
  for (let i2 = 0; i2 < node.sources.length; i2 += 1) {
    const source = node.sources[i2];
    if (source.sources) {
      const state = source.state;
      if (state === STALE) {
        if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);
      } else if (state === PENDING) lookUpstream(source, ignore);
    }
  }
}
function markDownstream(node) {
  for (let i2 = 0; i2 < node.observers.length; i2 += 1) {
    const o3 = node.observers[i2];
    if (!o3.state) {
      o3.state = PENDING;
      if (o3.pure) Updates.push(o3);
      else Effects.push(o3);
      o3.observers && markDownstream(o3);
    }
  }
}
function cleanNode(node) {
  let i2;
  if (node.sources) {
    while (node.sources.length) {
      const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;
      if (obs && obs.length) {
        const n2 = obs.pop(), s3 = source.observerSlots.pop();
        if (index < obs.length) {
          n2.sourceSlots[s3] = index;
          obs[index] = n2;
          source.observerSlots[index] = s3;
        }
      }
    }
  }
  if (node.tOwned) {
    for (i2 = node.tOwned.length - 1; i2 >= 0; i2--) cleanNode(node.tOwned[i2]);
    delete node.tOwned;
  }
  if (node.owned) {
    for (i2 = node.owned.length - 1; i2 >= 0; i2--) cleanNode(node.owned[i2]);
    node.owned = null;
  }
  if (node.cleanups) {
    for (i2 = node.cleanups.length - 1; i2 >= 0; i2--) node.cleanups[i2]();
    node.cleanups = null;
  }
  node.state = 0;
}
function castError(err) {
  if (err instanceof Error) return err;
  return new Error(typeof err === "string" ? err : "Unknown error", {
    cause: err
  });
}
function handleError(err, owner = Owner) {
  const error = castError(err);
  throw error;
}
var FALLBACK = Symbol("fallback");
function dispose(d3) {
  for (let i2 = 0; i2 < d3.length; i2++) d3[i2]();
}
function mapArray(list, mapFn, options = {}) {
  let items = [], mapped = [], disposers = [], len = 0, indexes = mapFn.length > 1 ? [] : null;
  onCleanup(() => dispose(disposers));
  return () => {
    let newItems = list() || [], newLen = newItems.length, i2, j2;
    newItems[$TRACK];
    return untrack(() => {
      let newIndices, newIndicesNext, temp, tempdisposers, tempIndexes, start, end, newEnd, item;
      if (newLen === 0) {
        if (len !== 0) {
          dispose(disposers);
          disposers = [];
          items = [];
          mapped = [];
          len = 0;
          indexes && (indexes = []);
        }
        if (options.fallback) {
          items = [FALLBACK];
          mapped[0] = createRoot((disposer) => {
            disposers[0] = disposer;
            return options.fallback();
          });
          len = 1;
        }
      } else if (len === 0) {
        mapped = new Array(newLen);
        for (j2 = 0; j2 < newLen; j2++) {
          items[j2] = newItems[j2];
          mapped[j2] = createRoot(mapper);
        }
        len = newLen;
      } else {
        temp = new Array(newLen);
        tempdisposers = new Array(newLen);
        indexes && (tempIndexes = new Array(newLen));
        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++) ;
        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {
          temp[newEnd] = mapped[end];
          tempdisposers[newEnd] = disposers[end];
          indexes && (tempIndexes[newEnd] = indexes[end]);
        }
        newIndices = /* @__PURE__ */ new Map();
        newIndicesNext = new Array(newEnd + 1);
        for (j2 = newEnd; j2 >= start; j2--) {
          item = newItems[j2];
          i2 = newIndices.get(item);
          newIndicesNext[j2] = i2 === void 0 ? -1 : i2;
          newIndices.set(item, j2);
        }
        for (i2 = start; i2 <= end; i2++) {
          item = items[i2];
          j2 = newIndices.get(item);
          if (j2 !== void 0 && j2 !== -1) {
            temp[j2] = mapped[i2];
            tempdisposers[j2] = disposers[i2];
            indexes && (tempIndexes[j2] = indexes[i2]);
            j2 = newIndicesNext[j2];
            newIndices.set(item, j2);
          } else disposers[i2]();
        }
        for (j2 = start; j2 < newLen; j2++) {
          if (j2 in temp) {
            mapped[j2] = temp[j2];
            disposers[j2] = tempdisposers[j2];
            if (indexes) {
              indexes[j2] = tempIndexes[j2];
              indexes[j2](j2);
            }
          } else mapped[j2] = createRoot(mapper);
        }
        mapped = mapped.slice(0, len = newLen);
        items = newItems.slice(0);
      }
      return mapped;
    });
    function mapper(disposer) {
      disposers[j2] = disposer;
      if (indexes) {
        const [s3, set] = createSignal(j2);
        indexes[j2] = set;
        return mapFn(newItems[j2], s3);
      }
      return mapFn(newItems[j2]);
    }
  };
}
function createComponent(Comp, props) {
  return untrack(() => Comp(props || {}));
}
var narrowedError = (name) => `Stale read from <${name}>.`;
function For(props) {
  const fallback = "fallback" in props && {
    fallback: () => props.fallback
  };
  return createMemo(mapArray(() => props.each, props.children, fallback || void 0));
}
function Show(props) {
  const keyed = props.keyed;
  const conditionValue = createMemo(() => props.when, void 0, void 0);
  const condition = keyed ? conditionValue : createMemo(conditionValue, void 0, {
    equals: (a3, b3) => !a3 === !b3
  });
  return createMemo(() => {
    const c3 = condition();
    if (c3) {
      const child = props.children;
      const fn = typeof child === "function" && child.length > 0;
      return fn ? untrack(() => child(keyed ? c3 : () => {
        if (!untrack(condition)) throw narrowedError("Show");
        return conditionValue();
      })) : child;
    }
    return props.fallback;
  }, void 0, void 0);
}
var memo = (fn) => createMemo(() => fn());
function reconcileArrays(parentNode, a3, b3) {
  let bLength = b3.length, aEnd = a3.length, bEnd = bLength, aStart = 0, bStart = 0, after = a3[aEnd - 1].nextSibling, map = null;
  while (aStart < aEnd || bStart < bEnd) {
    if (a3[aStart] === b3[bStart]) {
      aStart++;
      bStart++;
      continue;
    }
    while (a3[aEnd - 1] === b3[bEnd - 1]) {
      aEnd--;
      bEnd--;
    }
    if (aEnd === aStart) {
      const node = bEnd < bLength ? bStart ? b3[bStart - 1].nextSibling : b3[bEnd - bStart] : after;
      while (bStart < bEnd) parentNode.insertBefore(b3[bStart++], node);
    } else if (bEnd === bStart) {
      while (aStart < aEnd) {
        if (!map || !map.has(a3[aStart])) a3[aStart].remove();
        aStart++;
      }
    } else if (a3[aStart] === b3[bEnd - 1] && b3[bStart] === a3[aEnd - 1]) {
      const node = a3[--aEnd].nextSibling;
      parentNode.insertBefore(b3[bStart++], a3[aStart++].nextSibling);
      parentNode.insertBefore(b3[--bEnd], node);
      a3[aEnd] = b3[bEnd];
    } else {
      if (!map) {
        map = /* @__PURE__ */ new Map();
        let i2 = bStart;
        while (i2 < bEnd) map.set(b3[i2], i2++);
      }
      const index = map.get(a3[aStart]);
      if (index != null) {
        if (bStart < index && index < bEnd) {
          let i2 = aStart, sequence = 1, t2;
          while (++i2 < aEnd && i2 < bEnd) {
            if ((t2 = map.get(a3[i2])) == null || t2 !== index + sequence) break;
            sequence++;
          }
          if (sequence > index - bStart) {
            const node = a3[aStart];
            while (bStart < index) parentNode.insertBefore(b3[bStart++], node);
          } else parentNode.replaceChild(b3[bStart++], a3[aStart++]);
        } else aStart++;
      } else a3[aStart++].remove();
    }
  }
}
var $$EVENTS = "_$DX_DELEGATE";
function render(code, element, init2, options = {}) {
  let disposer;
  createRoot((dispose2) => {
    disposer = dispose2;
    element === document ? code() : insert(element, code(), element.firstChild ? null : void 0, init2);
  }, options.owner);
  return () => {
    disposer();
    element.textContent = "";
  };
}
function template(html, isImportNode, isSVG, isMathML) {
  let node;
  const create = () => {
    const t2 = document.createElement("template");
    t2.innerHTML = html;
    return t2.content.firstChild;
  };
  const fn = () => (node || (node = create())).cloneNode(true);
  fn.cloneNode = fn;
  return fn;
}
function delegateEvents(eventNames, document2 = window.document) {
  const e2 = document2[$$EVENTS] || (document2[$$EVENTS] = /* @__PURE__ */ new Set());
  for (let i2 = 0, l3 = eventNames.length; i2 < l3; i2++) {
    const name = eventNames[i2];
    if (!e2.has(name)) {
      e2.add(name);
      document2.addEventListener(name, eventHandler);
    }
  }
}
function setAttribute(node, name, value) {
  node.removeAttribute(name);
}
function className(node, value) {
  if (value == null) node.removeAttribute("class");
  else node.className = value;
}
function style(node, value, prev) {
  if (!value) return prev ? setAttribute(node, "style") : value;
  const nodeStyle = node.style;
  if (typeof value === "string") return nodeStyle.cssText = value;
  typeof prev === "string" && (nodeStyle.cssText = prev = void 0);
  prev || (prev = {});
  value || (value = {});
  let v2, s3;
  for (s3 in prev) {
    value[s3] == null && nodeStyle.removeProperty(s3);
    delete prev[s3];
  }
  for (s3 in value) {
    v2 = value[s3];
    if (v2 !== prev[s3]) {
      nodeStyle.setProperty(s3, v2);
      prev[s3] = v2;
    }
  }
  return prev;
}
function setStyleProperty(node, name, value) {
  value != null ? node.style.setProperty(name, value) : node.style.removeProperty(name);
}
function use(fn, element, arg) {
  return untrack(() => fn(element, arg));
}
function insert(parent, accessor, marker, initial) {
  if (marker !== void 0 && !initial) initial = [];
  if (typeof accessor !== "function") return insertExpression(parent, accessor, initial, marker);
  createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);
}
function eventHandler(e2) {
  let node = e2.target;
  const key = `$$${e2.type}`;
  const oriTarget = e2.target;
  const oriCurrentTarget = e2.currentTarget;
  const retarget = (value) => Object.defineProperty(e2, "target", {
    configurable: true,
    value
  });
  const handleNode = () => {
    const handler = node[key];
    if (handler && !node.disabled) {
      const data = node[`${key}Data`];
      data !== void 0 ? handler.call(node, data, e2) : handler.call(node, e2);
      if (e2.cancelBubble) return;
    }
    node.host && typeof node.host !== "string" && !node.host._$host && node.contains(e2.target) && retarget(node.host);
    return true;
  };
  const walkUpTree = () => {
    while (handleNode() && (node = node._$host || node.parentNode || node.host)) ;
  };
  Object.defineProperty(e2, "currentTarget", {
    configurable: true,
    get() {
      return node || document;
    }
  });
  if (e2.composedPath) {
    const path = e2.composedPath();
    retarget(path[0]);
    for (let i2 = 0; i2 < path.length - 2; i2++) {
      node = path[i2];
      if (!handleNode()) break;
      if (node._$host) {
        node = node._$host;
        walkUpTree();
        break;
      }
      if (node.parentNode === oriCurrentTarget) {
        break;
      }
    }
  } else walkUpTree();
  retarget(oriTarget);
}
function insertExpression(parent, value, current, marker, unwrapArray) {
  while (typeof current === "function") current = current();
  if (value === current) return current;
  const t2 = typeof value, multi = marker !== void 0;
  parent = multi && current[0] && current[0].parentNode || parent;
  if (t2 === "string" || t2 === "number") {
    if (t2 === "number") {
      value = value.toString();
      if (value === current) return current;
    }
    if (multi) {
      let node = current[0];
      if (node && node.nodeType === 3) {
        node.data !== value && (node.data = value);
      } else node = document.createTextNode(value);
      current = cleanChildren(parent, current, marker, node);
    } else {
      if (current !== "" && typeof current === "string") {
        current = parent.firstChild.data = value;
      } else current = parent.textContent = value;
    }
  } else if (value == null || t2 === "boolean") {
    current = cleanChildren(parent, current, marker);
  } else if (t2 === "function") {
    createRenderEffect(() => {
      let v2 = value();
      while (typeof v2 === "function") v2 = v2();
      current = insertExpression(parent, v2, current, marker);
    });
    return () => current;
  } else if (Array.isArray(value)) {
    const array = [];
    const currentArray = current && Array.isArray(current);
    if (normalizeIncomingArray(array, value, current, unwrapArray)) {
      createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));
      return () => current;
    }
    if (array.length === 0) {
      current = cleanChildren(parent, current, marker);
      if (multi) return current;
    } else if (currentArray) {
      if (current.length === 0) {
        appendNodes(parent, array, marker);
      } else reconcileArrays(parent, current, array);
    } else {
      current && cleanChildren(parent);
      appendNodes(parent, array);
    }
    current = array;
  } else if (value.nodeType) {
    if (Array.isArray(current)) {
      if (multi) return current = cleanChildren(parent, current, marker, value);
      cleanChildren(parent, current, null, value);
    } else if (current == null || current === "" || !parent.firstChild) {
      parent.appendChild(value);
    } else parent.replaceChild(value, parent.firstChild);
    current = value;
  } else ;
  return current;
}
function normalizeIncomingArray(normalized, array, current, unwrap) {
  let dynamic = false;
  for (let i2 = 0, len = array.length; i2 < len; i2++) {
    let item = array[i2], prev = current && current[normalized.length], t2;
    if (item == null || item === true || item === false) ;
    else if ((t2 = typeof item) === "object" && item.nodeType) {
      normalized.push(item);
    } else if (Array.isArray(item)) {
      dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;
    } else if (t2 === "function") {
      if (unwrap) {
        while (typeof item === "function") item = item();
        dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item], Array.isArray(prev) ? prev : [prev]) || dynamic;
      } else {
        normalized.push(item);
        dynamic = true;
      }
    } else {
      const value = String(item);
      if (prev && prev.nodeType === 3 && prev.data === value) normalized.push(prev);
      else normalized.push(document.createTextNode(value));
    }
  }
  return dynamic;
}
function appendNodes(parent, array, marker = null) {
  for (let i2 = 0, len = array.length; i2 < len; i2++) parent.insertBefore(array[i2], marker);
}
function cleanChildren(parent, current, marker, replacement) {
  if (marker === void 0) return parent.textContent = "";
  const node = replacement || document.createTextNode("");
  if (current.length) {
    let inserted = false;
    for (let i2 = current.length - 1; i2 >= 0; i2--) {
      const el = current[i2];
      if (node !== el) {
        const isParent = el.parentNode === parent;
        if (!inserted && !i2) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);
        else isParent && el.remove();
      } else inserted = true;
    }
  } else parent.insertBefore(node, marker);
  return [node];
}

// dist/styles.css
var styles_default = '/*! tailwindcss v4.1.17 | MIT License | https://tailwindcss.com */\n@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-rotate-x:initial;--tw-rotate-y:initial;--tw-rotate-z:initial;--tw-skew-x:initial;--tw-skew-y:initial;--tw-border-style:solid;--tw-leading:initial;--tw-font-weight:initial;--tw-ordinal:initial;--tw-slashed-zero:initial;--tw-numeric-figure:initial;--tw-numeric-spacing:initial;--tw-numeric-fraction:initial;--tw-blur:initial;--tw-brightness:initial;--tw-contrast:initial;--tw-grayscale:initial;--tw-hue-rotate:initial;--tw-invert:initial;--tw-opacity:initial;--tw-saturate:initial;--tw-sepia:initial;--tw-drop-shadow:initial;--tw-drop-shadow-color:initial;--tw-drop-shadow-alpha:100%;--tw-drop-shadow-size:initial;--tw-duration:initial;--tw-ease:initial}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-white:#fff;--spacing:.25rem;--font-weight-medium:500;--font-weight-semibold:600;--leading-tight:1.25;--ease-out:cubic-bezier(0,0,.2,1);--ease-in-out:cubic-bezier(.4,0,.2,1);--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono);--color-grab-pink:#b21c8e;--color-grab-pink-light:#fde7f7;--color-grab-pink-border:#f7c5ec;--color-grab-purple:#d239c0}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;-webkit-text-decoration:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab, red, red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}}@layer components;@layer utilities{.pointer-events-auto{pointer-events:auto}.pointer-events-none{pointer-events:none}.visible{visibility:visible}.absolute{position:absolute}.fixed{position:fixed}.relative{position:relative}.top-0{top:calc(var(--spacing)*0)}.bottom-0{bottom:calc(var(--spacing)*0)}.left-0{left:calc(var(--spacing)*0)}.z-2147483645{z-index:2147483645}.z-2147483646{z-index:2147483646}.z-\\[2147483645\\]{z-index:2147483645}.mt-0\\.5{margin-top:calc(var(--spacing)*.5)}.mr-1{margin-right:calc(var(--spacing)*1)}.ml-1{margin-left:calc(var(--spacing)*1)}.box-border{box-sizing:border-box}.block{display:block}.flex{display:flex}.hidden{display:none}.inline-block{display:inline-block}.h-2{height:calc(var(--spacing)*2)}.min-h-\\[18px\\]{min-height:18px}.w-2{width:calc(var(--spacing)*2)}.w-\\[240px\\]{width:240px}.transform{transform:var(--tw-rotate-x,)var(--tw-rotate-y,)var(--tw-rotate-z,)var(--tw-skew-x,)var(--tw-skew-y,)}.cursor-crosshair{cursor:crosshair}.resize{resize:both}.resize-y{resize:vertical}.flex-col{flex-direction:column}.items-center{align-items:center}.gap-0\\.5{gap:calc(var(--spacing)*.5)}.overflow-hidden{overflow:hidden}.rounded{border-radius:.25rem}.rounded-\\[3px\\]{border-radius:3px}.rounded-full{border-radius:3.40282e38px}.border{border-style:var(--tw-border-style);border-width:1px}.border-\\[1\\.5px\\]{border-style:var(--tw-border-style);border-width:1.5px}.border-dashed{--tw-border-style:dashed;border-style:dashed}.border-grab-pink-border{border-color:var(--color-grab-pink-border)}.border-grab-purple{border-color:var(--color-grab-purple)}.border-grab-purple\\/40{border-color:#d239c066}@supports (color:color-mix(in lab, red, red)){.border-grab-purple\\/40{border-color:color-mix(in oklab,var(--color-grab-purple)40%,transparent)}}.border-grab-purple\\/50{border-color:#d239c080}@supports (color:color-mix(in lab, red, red)){.border-grab-purple\\/50{border-color:color-mix(in oklab,var(--color-grab-purple)50%,transparent)}}.border-t-transparent{border-top-color:#0000}.bg-grab-pink-light{background-color:var(--color-grab-pink-light)}.bg-grab-pink\\/20{background-color:#b21c8e33}@supports (color:color-mix(in lab, red, red)){.bg-grab-pink\\/20{background-color:color-mix(in oklab,var(--color-grab-pink)20%,transparent)}}.bg-grab-purple\\/5{background-color:#d239c00d}@supports (color:color-mix(in lab, red, red)){.bg-grab-purple\\/5{background-color:color-mix(in oklab,var(--color-grab-purple)5%,transparent)}}.bg-grab-purple\\/8{background-color:#d239c014}@supports (color:color-mix(in lab, red, red)){.bg-grab-purple\\/8{background-color:color-mix(in oklab,var(--color-grab-purple)8%,transparent)}}.bg-white{background-color:var(--color-white)}.p-0\\.5{padding:calc(var(--spacing)*.5)}.px-1{padding-inline:calc(var(--spacing)*1)}.px-1\\.5{padding-inline:calc(var(--spacing)*1.5)}.px-\\[3px\\]{padding-inline:3px}.py-0\\.5{padding-block:calc(var(--spacing)*.5)}.text-center{text-align:center}.align-middle{vertical-align:middle}.font-mono{font-family:var(--font-mono)}.font-sans{font-family:var(--font-sans)}.text-\\[9px\\]{font-size:9px}.text-\\[10px\\]{font-size:10px}.text-\\[11px\\]{font-size:11px}.leading-tight{--tw-leading:var(--leading-tight);line-height:var(--leading-tight)}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.font-semibold{--tw-font-weight:var(--font-weight-semibold);font-weight:var(--font-weight-semibold)}.text-ellipsis{text-overflow:ellipsis}.whitespace-nowrap{white-space:nowrap}.text-grab-pink{color:var(--color-grab-pink)}.tabular-nums{--tw-numeric-spacing:tabular-nums;font-variant-numeric:var(--tw-ordinal,)var(--tw-slashed-zero,)var(--tw-numeric-figure,)var(--tw-numeric-spacing,)var(--tw-numeric-fraction,)}.opacity-60{opacity:.6}.filter{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.transition-\\[width\\]{transition-property:width;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-opacity{transition-property:opacity;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.duration-100{--tw-duration:.1s;transition-duration:.1s}.duration-200{--tw-duration:.2s;transition-duration:.2s}.duration-300{--tw-duration:.3s;transition-duration:.3s}.ease-in-out{--tw-ease:var(--ease-in-out);transition-timing-function:var(--ease-in-out)}.ease-out{--tw-ease:var(--ease-out);transition-timing-function:var(--ease-out)}.will-change-\\[transform\\,width\\,height\\]{will-change:transform,width,height}.outline-none{--tw-outline-style:none;outline-style:none}}@property --tw-rotate-x{syntax:"*";inherits:false}@property --tw-rotate-y{syntax:"*";inherits:false}@property --tw-rotate-z{syntax:"*";inherits:false}@property --tw-skew-x{syntax:"*";inherits:false}@property --tw-skew-y{syntax:"*";inherits:false}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-leading{syntax:"*";inherits:false}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-ordinal{syntax:"*";inherits:false}@property --tw-slashed-zero{syntax:"*";inherits:false}@property --tw-numeric-figure{syntax:"*";inherits:false}@property --tw-numeric-spacing{syntax:"*";inherits:false}@property --tw-numeric-fraction{syntax:"*";inherits:false}@property --tw-blur{syntax:"*";inherits:false}@property --tw-brightness{syntax:"*";inherits:false}@property --tw-contrast{syntax:"*";inherits:false}@property --tw-grayscale{syntax:"*";inherits:false}@property --tw-hue-rotate{syntax:"*";inherits:false}@property --tw-invert{syntax:"*";inherits:false}@property --tw-opacity{syntax:"*";inherits:false}@property --tw-saturate{syntax:"*";inherits:false}@property --tw-sepia{syntax:"*";inherits:false}@property --tw-drop-shadow{syntax:"*";inherits:false}@property --tw-drop-shadow-color{syntax:"*";inherits:false}@property --tw-drop-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-drop-shadow-size{syntax:"*";inherits:false}@property --tw-duration{syntax:"*";inherits:false}@property --tw-ease{syntax:"*";inherits:false}';

// src/utils/is-keyboard-event-triggered-by-input.ts
var FORM_TAGS_AND_ROLES = [
  "input",
  "textarea",
  "select",
  "searchbox",
  "slider",
  "spinbutton",
  "menuitem",
  "menuitemcheckbox",
  "menuitemradio",
  "option",
  "radio",
  "textbox"
];
var isCustomElement = (element) => {
  return Boolean(element.tagName) && !element.tagName.startsWith("-") && element.tagName.includes("-");
};
var isReadonlyArray = (value) => {
  return Array.isArray(value);
};
var isHotkeyEnabledOnTagName = (event, enabledOnTags = false) => {
  const { composed, target } = event;
  let targetTagName;
  let targetRole;
  if (target instanceof HTMLElement && isCustomElement(target) && composed) {
    const composedPath = event.composedPath();
    const targetElement = composedPath[0];
    if (targetElement instanceof HTMLElement) {
      targetTagName = targetElement.tagName;
      targetRole = targetElement.role;
    }
  } else if (target instanceof HTMLElement) {
    targetTagName = target.tagName;
    targetRole = target.role;
  }
  if (isReadonlyArray(enabledOnTags)) {
    return Boolean(
      targetTagName && enabledOnTags && enabledOnTags.some(
        (tag) => typeof targetTagName === "string" && tag.toLowerCase() === targetTagName.toLowerCase() || tag === targetRole
      )
    );
  }
  return Boolean(targetTagName && enabledOnTags && enabledOnTags);
};
var isKeyboardEventTriggeredByInput = (event) => {
  return isHotkeyEnabledOnTagName(event, FORM_TAGS_AND_ROLES);
};

// src/utils/mount-root.ts
var ATTRIBUTE_NAME = "data-react-grab";
var mountRoot = (cssText) => {
  const mountedHost = document.querySelector(`[${ATTRIBUTE_NAME}]`);
  if (mountedHost) {
    const mountedRoot = mountedHost.shadowRoot?.querySelector(
      `[${ATTRIBUTE_NAME}]`
    );
    if (mountedRoot instanceof HTMLDivElement && mountedHost.shadowRoot) {
      return mountedRoot;
    }
  }
  const host = document.createElement("div");
  host.setAttribute(ATTRIBUTE_NAME, "true");
  host.style.zIndex = "2147483646";
  host.style.position = "fixed";
  host.style.top = "0";
  host.style.left = "0";
  const shadowRoot = host.attachShadow({ mode: "open" });
  {
    const styleElement = document.createElement("style");
    styleElement.textContent = cssText;
    shadowRoot.appendChild(styleElement);
  }
  const root = document.createElement("div");
  root.setAttribute(ATTRIBUTE_NAME, "true");
  shadowRoot.appendChild(root);
  const doc = document.body ?? document.documentElement;
  doc.appendChild(host);
  return root;
};

// src/constants.ts
var VIEWPORT_MARGIN_PX = 8;
var INDICATOR_CLAMP_PADDING_PX = 4;
var CURSOR_OFFSET_PX = 14;
var OFFSCREEN_POSITION = -1e3;
var SELECTION_LERP_FACTOR = 0.95;
var SUCCESS_LABEL_DURATION_MS = 1700;
var PROGRESS_INDICATOR_DELAY_MS = 150;
var DRAG_THRESHOLD_PX = 2;
var AUTO_SCROLL_EDGE_THRESHOLD_PX = 25;
var AUTO_SCROLL_SPEED_PX = 10;
var Z_INDEX_LABEL = 2147483647;

// src/utils/lerp.ts
var lerp = (start, end, factor) => {
  return start + (end - start) * factor;
};

// ../../node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs
function r(e2) {
  var t2, f3, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2) n2 += e2;
  else if ("object" == typeof e2) if (Array.isArray(e2)) {
    var o3 = e2.length;
    for (t2 = 0; t2 < o3; t2++) e2[t2] && (f3 = r(e2[t2])) && (n2 && (n2 += " "), n2 += f3);
  } else for (f3 in e2) e2[f3] && (n2 && (n2 += " "), n2 += f3);
  return n2;
}
function clsx() {
  for (var e2, t2, f3 = 0, n2 = "", o3 = arguments.length; f3 < o3; f3++) (e2 = arguments[f3]) && (t2 = r(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}

// ../../node_modules/.pnpm/tailwind-merge@2.6.0/node_modules/tailwind-merge/dist/bundle-mjs.mjs
var CLASS_PART_SEPARATOR = "-";
var createClassGroupUtils = (config) => {
  const classMap = createClassMap(config);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config;
  const getClassGroupId = (className2) => {
    const classParts = className2.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className2);
  };
  const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
    const conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
    }
    return conflicts;
  };
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
};
var getGroupRecursive = (classParts, classPartObject) => {
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[0];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  const classRest = classParts.join(CLASS_PART_SEPARATOR);
  return classPartObject.validators.find(({
    validator
  }) => validator(classRest))?.classGroupId;
};
var arbitraryPropertyRegex = /^\[(.+)\]$/;
var getGroupIdForArbitraryProperty = (className2) => {
  if (arbitraryPropertyRegex.test(className2)) {
    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className2)[1];
    const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
};
var createClassMap = (config) => {
  const {
    theme,
    prefix
  } = config;
  const classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
  prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
    processClassesRecursively(classGroup, classMap, classGroupId, theme);
  });
  return classMap;
};
var processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {
  classGroup.forEach((classDefinition) => {
    if (typeof classDefinition === "string") {
      const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(([key, classGroup2]) => {
      processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
    });
  });
};
var getPart = (classPartObject, path) => {
  let currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
};
var isThemeGetter = (func) => func.isThemeGetter;
var getPrefixedClassGroupEntries = (classGroupEntries, prefix) => {
  if (!prefix) {
    return classGroupEntries;
  }
  return classGroupEntries.map(([classGroupId, classGroup]) => {
    const prefixedClassGroup = classGroup.map((classDefinition) => {
      if (typeof classDefinition === "string") {
        return prefix + classDefinition;
      }
      if (typeof classDefinition === "object") {
        return Object.fromEntries(Object.entries(classDefinition).map(([key, value]) => [prefix + key, value]));
      }
      return classDefinition;
    });
    return [classGroupId, prefixedClassGroup];
  });
};
var createLruCache = (maxCacheSize) => {
  if (maxCacheSize < 1) {
    return {
      get: () => void 0,
      set: () => {
      }
    };
  }
  let cacheSize = 0;
  let cache = /* @__PURE__ */ new Map();
  let previousCache = /* @__PURE__ */ new Map();
  const update = (key, value) => {
    cache.set(key, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = /* @__PURE__ */ new Map();
    }
  };
  return {
    get(key) {
      let value = cache.get(key);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key)) !== void 0) {
        update(key, value);
        return value;
      }
    },
    set(key, value) {
      if (cache.has(key)) {
        cache.set(key, value);
      } else {
        update(key, value);
      }
    }
  };
};
var IMPORTANT_MODIFIER = "!";
var createParseClassName = (config) => {
  const {
    separator,
    experimentalParseClassName
  } = config;
  const isSeparatorSingleCharacter = separator.length === 1;
  const firstSeparatorCharacter = separator[0];
  const separatorLength = separator.length;
  const parseClassName = (className2) => {
    const modifiers = [];
    let bracketDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    for (let index = 0; index < className2.length; index++) {
      let currentCharacter = className2[index];
      if (bracketDepth === 0) {
        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className2.slice(index, index + separatorLength) === separator)) {
          modifiers.push(className2.slice(modifierStart, index));
          modifierStart = index + separatorLength;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      }
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className2 : className2.substring(modifierStart);
    const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
    const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
  if (experimentalParseClassName) {
    return (className2) => experimentalParseClassName({
      className: className2,
      parseClassName
    });
  }
  return parseClassName;
};
var sortModifiers = (modifiers) => {
  if (modifiers.length <= 1) {
    return modifiers;
  }
  const sortedModifiers = [];
  let unsortedModifiers = [];
  modifiers.forEach((modifier) => {
    const isArbitraryVariant = modifier[0] === "[";
    if (isArbitraryVariant) {
      sortedModifiers.push(...unsortedModifiers.sort(), modifier);
      unsortedModifiers = [];
    } else {
      unsortedModifiers.push(modifier);
    }
  });
  sortedModifiers.push(...unsortedModifiers.sort());
  return sortedModifiers;
};
var createConfigUtils = (config) => ({
  cache: createLruCache(config.cacheSize),
  parseClassName: createParseClassName(config),
  ...createClassGroupUtils(config)
});
var SPLIT_CLASSES_REGEX = /\s+/;
var mergeClassList = (classList, configUtils) => {
  const {
    parseClassName,
    getClassGroupId,
    getConflictingClassGroupIds
  } = configUtils;
  const classGroupsInConflict = [];
  const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
  let result = "";
  for (let index = classNames.length - 1; index >= 0; index -= 1) {
    const originalClassName = classNames[index];
    const {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = parseClassName(originalClassName);
    let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
    let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    if (!classGroupId) {
      if (!hasPostfixModifier) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      hasPostfixModifier = false;
    }
    const variantModifier = sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.includes(classId)) {
      continue;
    }
    classGroupsInConflict.push(classId);
    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
    for (let i2 = 0; i2 < conflictGroups.length; ++i2) {
      const group = conflictGroups[i2];
      classGroupsInConflict.push(modifierId + group);
    }
    result = originalClassName + (result.length > 0 ? " " + result : result);
  }
  return result;
};
function twJoin() {
  let index = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index < arguments.length) {
    if (argument = arguments[index++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
var toValue = (mix) => {
  if (typeof mix === "string") {
    return mix;
  }
  let resolvedValue;
  let string = "";
  for (let k3 = 0; k3 < mix.length; k3++) {
    if (mix[k3]) {
      if (resolvedValue = toValue(mix[k3])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
};
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
var fromTheme = (key) => {
  const themeGetter = (theme) => theme[key] || [];
  themeGetter.isThemeGetter = true;
  return themeGetter;
};
var arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
var fractionRegex = /^\d+\/\d+$/;
var stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
var tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
var lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
var colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
var shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
var imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
var isLength = (value) => isNumber(value) || stringLengths.has(value) || fractionRegex.test(value);
var isArbitraryLength = (value) => getIsArbitraryValue(value, "length", isLengthOnly);
var isNumber = (value) => Boolean(value) && !Number.isNaN(Number(value));
var isArbitraryNumber = (value) => getIsArbitraryValue(value, "number", isNumber);
var isInteger = (value) => Boolean(value) && Number.isInteger(Number(value));
var isPercent = (value) => value.endsWith("%") && isNumber(value.slice(0, -1));
var isArbitraryValue = (value) => arbitraryValueRegex.test(value);
var isTshirtSize = (value) => tshirtUnitRegex.test(value);
var sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
var isArbitrarySize = (value) => getIsArbitraryValue(value, sizeLabels, isNever);
var isArbitraryPosition = (value) => getIsArbitraryValue(value, "position", isNever);
var imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
var isArbitraryImage = (value) => getIsArbitraryValue(value, imageLabels, isImage);
var isArbitraryShadow = (value) => getIsArbitraryValue(value, "", isShadow);
var isAny = () => true;
var getIsArbitraryValue = (value, label, testValue) => {
  const result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return typeof label === "string" ? result[1] === label : label.has(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
};
var isLengthOnly = (value) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  lengthUnitRegex.test(value) && !colorFunctionRegex.test(value)
);
var isNever = () => false;
var isShadow = (value) => shadowRegex.test(value);
var isImage = (value) => imageRegex.test(value);
var getDefaultConfig = () => {
  const colors = fromTheme("colors");
  const spacing = fromTheme("spacing");
  const blur = fromTheme("blur");
  const brightness = fromTheme("brightness");
  const borderColor = fromTheme("borderColor");
  const borderRadius = fromTheme("borderRadius");
  const borderSpacing = fromTheme("borderSpacing");
  const borderWidth = fromTheme("borderWidth");
  const contrast = fromTheme("contrast");
  const grayscale = fromTheme("grayscale");
  const hueRotate = fromTheme("hueRotate");
  const invert = fromTheme("invert");
  const gap = fromTheme("gap");
  const gradientColorStops = fromTheme("gradientColorStops");
  const gradientColorStopPositions = fromTheme("gradientColorStopPositions");
  const inset = fromTheme("inset");
  const margin = fromTheme("margin");
  const opacity = fromTheme("opacity");
  const padding = fromTheme("padding");
  const saturate = fromTheme("saturate");
  const scale = fromTheme("scale");
  const sepia = fromTheme("sepia");
  const skew = fromTheme("skew");
  const space = fromTheme("space");
  const translate = fromTheme("translate");
  const getOverscroll = () => ["auto", "contain", "none"];
  const getOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const getSpacingWithAutoAndArbitrary = () => ["auto", isArbitraryValue, spacing];
  const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];
  const getLengthWithEmptyAndArbitrary = () => ["", isLength, isArbitraryLength];
  const getNumberWithAutoAndArbitrary = () => ["auto", isNumber, isArbitraryValue];
  const getPositions = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  const getLineStyles = () => ["solid", "dashed", "dotted", "double", "none"];
  const getBlendModes = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
  const getAlign = () => ["start", "end", "center", "between", "around", "evenly", "stretch"];
  const getZeroAndEmpty = () => ["", "0", isArbitraryValue];
  const getBreaks = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const getNumberAndArbitrary = () => [isNumber, isArbitraryValue];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [isAny],
      spacing: [isLength, isArbitraryLength],
      blur: ["none", "", isTshirtSize, isArbitraryValue],
      brightness: getNumberAndArbitrary(),
      borderColor: [colors],
      borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
      borderSpacing: getSpacingWithArbitrary(),
      borderWidth: getLengthWithEmptyAndArbitrary(),
      contrast: getNumberAndArbitrary(),
      grayscale: getZeroAndEmpty(),
      hueRotate: getNumberAndArbitrary(),
      invert: getZeroAndEmpty(),
      gap: getSpacingWithArbitrary(),
      gradientColorStops: [colors],
      gradientColorStopPositions: [isPercent, isArbitraryLength],
      inset: getSpacingWithAutoAndArbitrary(),
      margin: getSpacingWithAutoAndArbitrary(),
      opacity: getNumberAndArbitrary(),
      padding: getSpacingWithArbitrary(),
      saturate: getNumberAndArbitrary(),
      scale: getNumberAndArbitrary(),
      sepia: getZeroAndEmpty(),
      skew: getNumberAndArbitrary(),
      space: getSpacingWithArbitrary(),
      translate: getSpacingWithArbitrary()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", isArbitraryValue]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isTshirtSize]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": getBreaks()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": getBreaks()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...getPositions(), isArbitraryValue]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: getOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": getOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": getOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: getOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": getOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": getOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [inset]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [inset]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [inset]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [inset]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [inset]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [inset]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [inset]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [inset]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [inset]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", isInteger, isArbitraryValue]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: getSpacingWithAutoAndArbitrary()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: getZeroAndEmpty()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: getZeroAndEmpty()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", isInteger, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [isAny]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [isAny]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [gap]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [gap]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [gap]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...getAlign()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...getAlign(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...getAlign(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [padding]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [padding]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [padding]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [padding]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [padding]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [padding]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [padding]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [padding]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [padding]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [margin]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [margin]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [margin]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [margin]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [margin]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [margin]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [margin]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [margin]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [margin]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [space]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [space]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", isArbitraryValue, spacing]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [isArbitraryValue, spacing, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [isArbitraryValue, spacing, "none", "full", "min", "max", "fit", "prose", {
          screen: [isTshirtSize]
        }, isTshirtSize]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [isArbitraryValue, spacing, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", isTshirtSize, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isAny]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", isNumber, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength, isArbitraryValue]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryValue]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [colors]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [opacity]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [colors]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [opacity]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...getLineStyles(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", isLength, isArbitraryLength]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", isLength, isArbitraryValue]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [colors]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: getSpacingWithArbitrary()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryValue]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [opacity]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...getPositions(), isArbitraryPosition]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitrarySize]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [colors]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [gradientColorStops]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [borderRadius]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [borderRadius]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [borderRadius]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [borderRadius]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [borderRadius]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [borderRadius]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [borderRadius]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [borderRadius]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [borderRadius]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [borderRadius]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [borderRadius]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [borderRadius]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [borderRadius]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [borderRadius]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [borderRadius]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [borderWidth]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [borderWidth]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [borderWidth]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [borderWidth]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [borderWidth]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [borderWidth]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [borderWidth]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [borderWidth]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [borderWidth]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [opacity]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...getLineStyles(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [borderWidth]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [borderWidth]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [opacity]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: getLineStyles()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [borderColor]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [borderColor]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [borderColor]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [borderColor]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [borderColor]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [borderColor]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [borderColor]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [borderColor]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [borderColor]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [borderColor]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...getLineStyles()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isLength, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [isLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [colors]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: getLengthWithEmptyAndArbitrary()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [colors]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [opacity]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [isLength, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [colors]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [isAny]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [opacity]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...getBlendModes(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": getBlendModes()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [blur]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [brightness]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [contrast]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [grayscale]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [hueRotate]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [invert]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [saturate]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [sepia]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [blur]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [brightness]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [contrast]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [grayscale]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [hueRotate]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [invert]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [opacity]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [saturate]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [sepia]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [borderSpacing]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [borderSpacing]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [borderSpacing]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: getNumberAndArbitrary()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: getNumberAndArbitrary()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [scale]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [scale]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [scale]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [isInteger, isArbitraryValue]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [translate]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [translate]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [skew]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [skew]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", colors]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [colors]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [colors, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [colors, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
};
var twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);

// src/utils/cn.ts
var cn = (...inputs) => {
  return twMerge(clsx(inputs));
};

// src/components/selection-box.tsx
var _tmpl$ = /* @__PURE__ */ template(`<div>`);
var SelectionBox = (props) => {
  const [currentX, setCurrentX] = createSignal(props.bounds.x);
  const [currentY, setCurrentY] = createSignal(props.bounds.y);
  const [currentWidth, setCurrentWidth] = createSignal(props.bounds.width);
  const [currentHeight, setCurrentHeight] = createSignal(props.bounds.height);
  const [opacity, setOpacity] = createSignal(1);
  let hasBeenRenderedOnce = false;
  let animationFrameId = null;
  let fadeTimerId = null;
  let targetBounds = props.bounds;
  let isAnimating = false;
  const lerpFactor = () => {
    if (props.lerpFactor !== void 0) return props.lerpFactor;
    if (props.variant === "drag") return 0.7;
    return SELECTION_LERP_FACTOR;
  };
  const startAnimation = () => {
    if (isAnimating) return;
    isAnimating = true;
    const animate = () => {
      const interpolatedX = lerp(currentX(), targetBounds.x, lerpFactor());
      const interpolatedY = lerp(currentY(), targetBounds.y, lerpFactor());
      const interpolatedWidth = lerp(currentWidth(), targetBounds.width, lerpFactor());
      const interpolatedHeight = lerp(currentHeight(), targetBounds.height, lerpFactor());
      setCurrentX(interpolatedX);
      setCurrentY(interpolatedY);
      setCurrentWidth(interpolatedWidth);
      setCurrentHeight(interpolatedHeight);
      const hasConvergedToTarget = Math.abs(interpolatedX - targetBounds.x) < 0.5 && Math.abs(interpolatedY - targetBounds.y) < 0.5 && Math.abs(interpolatedWidth - targetBounds.width) < 0.5 && Math.abs(interpolatedHeight - targetBounds.height) < 0.5;
      if (!hasConvergedToTarget) {
        animationFrameId = requestAnimationFrame(animate);
      } else {
        animationFrameId = null;
        isAnimating = false;
      }
    };
    animationFrameId = requestAnimationFrame(animate);
  };
  createEffect(on(() => props.bounds, (newBounds) => {
    targetBounds = newBounds;
    if (!hasBeenRenderedOnce) {
      setCurrentX(targetBounds.x);
      setCurrentY(targetBounds.y);
      setCurrentWidth(targetBounds.width);
      setCurrentHeight(targetBounds.height);
      hasBeenRenderedOnce = true;
      return;
    }
    startAnimation();
  }));
  createEffect(() => {
    if (props.variant === "grabbed" && props.createdAt) {
      fadeTimerId = window.setTimeout(() => {
        setOpacity(0);
      }, 1500);
    }
  });
  onCleanup(() => {
    if (animationFrameId !== null) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
    }
    if (fadeTimerId !== null) {
      window.clearTimeout(fadeTimerId);
      fadeTimerId = null;
    }
    isAnimating = false;
  });
  return createComponent(Show, {
    get when() {
      return props.visible !== false;
    },
    get children() {
      var _el$ = _tmpl$();
      createRenderEffect((_p$) => {
        var _v$ = cn("fixed box-border", props.variant === "drag" && "pointer-events-none", props.variant !== "drag" && "pointer-events-auto", props.variant === "grabbed" && "z-2147483645", props.variant !== "grabbed" && "z-2147483646", props.variant === "drag" && "border border-dashed border-grab-purple/40 bg-grab-purple/5 will-change-[transform,width,height] cursor-crosshair", props.variant === "selection" && "border border-dashed border-grab-purple/50 bg-grab-purple/8", props.variant === "grabbed" && "border border-grab-purple bg-grab-purple/8 transition-opacity duration-300 ease-out"), _v$2 = `${currentY()}px`, _v$3 = `${currentX()}px`, _v$4 = `${currentWidth()}px`, _v$5 = `${currentHeight()}px`, _v$6 = props.bounds.borderRadius, _v$7 = props.bounds.transform, _v$8 = opacity(), _v$9 = props.variant === "drag" ? "layout paint size" : void 0;
        _v$ !== _p$.e && className(_el$, _p$.e = _v$);
        _v$2 !== _p$.t && setStyleProperty(_el$, "top", _p$.t = _v$2);
        _v$3 !== _p$.a && setStyleProperty(_el$, "left", _p$.a = _v$3);
        _v$4 !== _p$.o && setStyleProperty(_el$, "width", _p$.o = _v$4);
        _v$5 !== _p$.i && setStyleProperty(_el$, "height", _p$.i = _v$5);
        _v$6 !== _p$.n && setStyleProperty(_el$, "border-radius", _p$.n = _v$6);
        _v$7 !== _p$.s && setStyleProperty(_el$, "transform", _p$.s = _v$7);
        _v$8 !== _p$.h && setStyleProperty(_el$, "opacity", _p$.h = _v$8);
        _v$9 !== _p$.r && setStyleProperty(_el$, "contain", _p$.r = _v$9);
        return _p$;
      }, {
        e: void 0,
        t: void 0,
        a: void 0,
        o: void 0,
        i: void 0,
        n: void 0,
        s: void 0,
        h: void 0,
        r: void 0
      });
      return _el$;
    }
  });
};

// src/components/spinner.tsx
var _tmpl$2 = /* @__PURE__ */ template(`<span class="inline-block w-2 h-2 border-[1.5px] border-grab-dark-pink border-t-transparent rounded-full mr-1 align-middle">`);
var Spinner = (props) => {
  let spinnerRef;
  onMount(() => {
    if (spinnerRef) {
      spinnerRef.animate([{
        transform: "rotate(0deg)"
      }, {
        transform: "rotate(360deg)"
      }], {
        duration: 600,
        easing: "linear",
        iterations: Infinity
      });
    }
  });
  return (() => {
    var _el$ = _tmpl$2();
    var _ref$ = spinnerRef;
    typeof _ref$ === "function" ? use(_ref$, _el$) : spinnerRef = _el$;
    createRenderEffect((_$p) => style(_el$, props.style, _$p));
    return _el$;
  })();
};

// src/utils/get-clamped-element-position.ts
var getClampedElementPosition = (positionLeft, positionTop, elementWidth, elementHeight) => {
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;
  const minLeft = VIEWPORT_MARGIN_PX;
  const minTop = VIEWPORT_MARGIN_PX;
  const maxLeft = viewportWidth - elementWidth - VIEWPORT_MARGIN_PX;
  const maxTop = viewportHeight - elementHeight - VIEWPORT_MARGIN_PX;
  const clampedLeft = Math.max(minLeft, Math.min(positionLeft, maxLeft));
  const clampedTop = Math.max(minTop, Math.min(positionTop, maxTop));
  return { left: clampedLeft, top: clampedTop };
};

// src/hooks/use-animated-lerp.ts
var useAnimatedPosition = (options) => {
  const lerpFactor = options.lerpFactor ?? 0.3;
  const convergenceThreshold = options.convergenceThreshold ?? 0.5;
  const [x3, setX] = createSignal(options.x());
  const [y2, setY] = createSignal(options.y());
  let targetX = options.x();
  let targetY = options.y();
  let animationFrameId = null;
  let hasBeenRenderedOnce = false;
  const animate = () => {
    const currentX = lerp(x3(), targetX, lerpFactor);
    const currentY = lerp(y2(), targetY, lerpFactor);
    setX(currentX);
    setY(currentY);
    const hasConverged = Math.abs(currentX - targetX) < convergenceThreshold && Math.abs(currentY - targetY) < convergenceThreshold;
    if (!hasConverged) {
      animationFrameId = requestAnimationFrame(animate);
    } else {
      animationFrameId = null;
    }
  };
  const startAnimation = () => {
    if (animationFrameId !== null) return;
    animationFrameId = requestAnimationFrame(animate);
  };
  createEffect(() => {
    targetX = options.x();
    targetY = options.y();
    if (!hasBeenRenderedOnce) {
      setX(targetX);
      setY(targetY);
      hasBeenRenderedOnce = true;
      return;
    }
    startAnimation();
  });
  onCleanup(() => {
    if (animationFrameId !== null) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
    }
  });
  return { x: x3, y: y2 };
};

// src/hooks/use-fade-in-out.ts
var useFadeInOut = (options) => {
  const [opacity, setOpacity] = createSignal(0);
  createEffect(
    on(
      () => options.visible,
      (isVisible) => {
        if (isVisible !== false) {
          requestAnimationFrame(() => {
            setOpacity(1);
          });
        } else {
          setOpacity(0);
          return;
        }
        if (options.autoFadeOutAfter !== void 0) {
          const fadeOutTimer = setTimeout(() => {
            setOpacity(0);
          }, options.autoFadeOutAfter);
          onCleanup(() => clearTimeout(fadeOutTimer));
        }
      }
    )
  );
  return opacity;
};

// src/utils/get-cursor-quadrants.ts
var getCursorQuadrants = (cursorX, cursorY, elementWidth, elementHeight, offset) => {
  return [
    {
      left: Math.round(cursorX) + offset,
      top: Math.round(cursorY) + offset
    },
    {
      left: Math.round(cursorX) - elementWidth - offset,
      top: Math.round(cursorY) + offset
    },
    {
      left: Math.round(cursorX) + offset,
      top: Math.round(cursorY) - elementHeight - offset
    },
    {
      left: Math.round(cursorX) - elementWidth - offset,
      top: Math.round(cursorY) - elementHeight - offset
    }
  ];
};

// src/components/label.tsx
var _tmpl$3 = /* @__PURE__ */ template(`<div class="absolute top-0 left-0 bottom-0 bg-grab-pink/20 rounded-[3px] transition-[width] duration-100 ease-out pointer-events-none">`);
var _tmpl$22 = /* @__PURE__ */ template(`<span class="inline-block mr-1 font-semibold">\u2713`);
var _tmpl$32 = /* @__PURE__ */ template(`<div class=mr-1>Copied`);
var _tmpl$4 = /* @__PURE__ */ template(`<div class=ml-1>to clipboard`);
var _tmpl$5 = /* @__PURE__ */ template(`<div class="text-[9px] opacity-60 text-center mt-0.5">Click or drag to select`);
var _tmpl$6 = /* @__PURE__ */ template(`<div class="fixed bg-grab-pink-light text-grab-pink border border-grab-pink-border rounded text-[11px] font-medium font-sans pointer-events-none transition-opacity duration-200 ease-in-out overflow-hidden"style="max-width:calc(100vw - (16px + env(safe-area-inset-left) + env(safe-area-inset-right)))"><div class="relative py-0.5 px-1.5 flex flex-col"><div class="flex items-center text-ellipsis whitespace-nowrap">`);
var Label = (props) => {
  let labelRef;
  const position = useAnimatedPosition({
    x: () => props.x,
    y: () => props.y,
    lerpFactor: 0.3
  });
  const opacity = useFadeInOut({
    visible: props.visible,
    autoFadeOutAfter: props.variant === "success" ? SUCCESS_LABEL_DURATION_MS : void 0
  });
  const labelBoundingRect = () => labelRef?.getBoundingClientRect();
  const computedPosition = () => {
    const boundingRect = labelBoundingRect();
    if (!boundingRect) return {
      left: position.x(),
      top: position.y()
    };
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    const quadrants = getCursorQuadrants(position.x(), position.y(), boundingRect.width, boundingRect.height, CURSOR_OFFSET_PX);
    for (const position2 of quadrants) {
      const fitsHorizontally = position2.left >= VIEWPORT_MARGIN_PX && position2.left + boundingRect.width <= viewportWidth - VIEWPORT_MARGIN_PX;
      const fitsVertically = position2.top >= VIEWPORT_MARGIN_PX && position2.top + boundingRect.height <= viewportHeight - VIEWPORT_MARGIN_PX;
      if (fitsHorizontally && fitsVertically) {
        return position2;
      }
    }
    const fallback = getClampedElementPosition(quadrants[0].left, quadrants[0].top, boundingRect.width, boundingRect.height);
    fallback.left += INDICATOR_CLAMP_PADDING_PX;
    fallback.top += INDICATOR_CLAMP_PADDING_PX;
    return fallback;
  };
  return createComponent(Show, {
    get when() {
      return props.visible !== false;
    },
    get children() {
      var _el$ = _tmpl$6(), _el$3 = _el$.firstChild, _el$4 = _el$3.firstChild;
      var _ref$ = labelRef;
      typeof _ref$ === "function" ? use(_ref$, _el$) : labelRef = _el$;
      insert(_el$, createComponent(Show, {
        get when() {
          return memo(() => props.variant === "processing")() && props.progress !== void 0;
        },
        get children() {
          var _el$2 = _tmpl$3();
          createRenderEffect((_$p) => setStyleProperty(_el$2, "width", `${Math.min(100, Math.max(0, (props.progress ?? 0) * 100))}%`));
          return _el$2;
        }
      }), _el$3);
      insert(_el$4, createComponent(Show, {
        get when() {
          return props.variant === "processing";
        },
        get children() {
          return createComponent(Spinner, {});
        }
      }), null);
      insert(_el$4, createComponent(Show, {
        get when() {
          return props.variant === "success";
        },
        get children() {
          return _tmpl$22();
        }
      }), null);
      insert(_el$4, createComponent(Show, {
        get when() {
          return props.variant === "success";
        },
        get children() {
          return _tmpl$32();
        }
      }), null);
      insert(_el$4, createComponent(Show, {
        get when() {
          return props.variant === "processing";
        },
        children: "Please wait\u2026"
      }), null);
      insert(_el$4, createComponent(Show, {
        get when() {
          return props.variant !== "processing";
        },
        get children() {
          return props.content;
        }
      }), null);
      insert(_el$4, createComponent(Show, {
        get when() {
          return props.variant === "success";
        },
        get children() {
          return _tmpl$4();
        }
      }), null);
      insert(_el$3, createComponent(Show, {
        get when() {
          return memo(() => props.variant === "hover")() && props.showHint;
        },
        get children() {
          return _tmpl$5();
        }
      }), null);
      createRenderEffect((_p$) => {
        var _v$ = `${computedPosition().top}px`, _v$2 = `${computedPosition().left}px`, _v$3 = props.zIndex?.toString() ?? "2147483647", _v$4 = opacity();
        _v$ !== _p$.e && setStyleProperty(_el$, "top", _p$.e = _v$);
        _v$2 !== _p$.t && setStyleProperty(_el$, "left", _p$.t = _v$2);
        _v$3 !== _p$.a && setStyleProperty(_el$, "z-index", _p$.a = _v$3);
        _v$4 !== _p$.o && setStyleProperty(_el$, "opacity", _p$.o = _v$4);
        return _p$;
      }, {
        e: void 0,
        t: void 0,
        a: void 0,
        o: void 0
      });
      return _el$;
    }
  });
};

// src/components/crosshair.tsx
var _tmpl$7 = /* @__PURE__ */ template(`<canvas class="fixed top-0 left-0 pointer-events-none z-[2147483645]">`);
var Crosshair = (props) => {
  let canvasRef;
  let context = null;
  let width = 0;
  let height = 0;
  let dpr = 1;
  const position = useAnimatedPosition({
    x: () => props.mouseX,
    y: () => props.mouseY,
    lerpFactor: 0.3
  });
  const setupCanvas = () => {
    if (!canvasRef) return;
    dpr = Math.max(window.devicePixelRatio || 1, 2);
    width = window.innerWidth;
    height = window.innerHeight;
    canvasRef.width = width * dpr;
    canvasRef.height = height * dpr;
    canvasRef.style.width = `${width}px`;
    canvasRef.style.height = `${height}px`;
    context = canvasRef.getContext("2d");
    if (context) {
      context.scale(dpr, dpr);
    }
  };
  const render2 = () => {
    if (!context) return;
    context.clearRect(0, 0, width, height);
    context.strokeStyle = "rgba(210, 57, 192)";
    context.lineWidth = 1;
    context.beginPath();
    context.moveTo(position.x(), 0);
    context.lineTo(position.x(), height);
    context.moveTo(0, position.y());
    context.lineTo(width, position.y());
    context.stroke();
  };
  createEffect(() => {
    setupCanvas();
    render2();
    const handleResize = () => {
      setupCanvas();
      render2();
    };
    window.addEventListener("resize", handleResize);
    onCleanup(() => {
      window.removeEventListener("resize", handleResize);
    });
  });
  createEffect(() => {
    position.x();
    position.y();
    render2();
  });
  return createComponent(Show, {
    get when() {
      return props.visible !== false;
    },
    get children() {
      var _el$ = _tmpl$7();
      var _ref$ = canvasRef;
      typeof _ref$ === "function" ? use(_ref$, _el$) : canvasRef = _el$;
      return _el$;
    }
  });
};

// src/components/input-overlay.tsx
var _tmpl$8 = /* @__PURE__ */ template(`<div data-react-grab-input class="fixed bg-grab-pink-light text-grab-pink border border-grab-pink-border rounded text-[11px] font-medium font-sans overflow-hidden"style="max-width:calc(100vw - (16px + env(safe-area-inset-left) + env(safe-area-inset-right)))"><div class="relative p-0.5 px-[3px] flex flex-col gap-0.5"><textarea placeholder="e.g., Make this button larger"rows=1 class="w-[240px] px-1 py-0.5 bg-white text-grab-pink border border-grab-pink-border rounded-[3px] text-[11px] leading-tight font-sans outline-none resize-y min-h-[18px]"></textarea><div class="text-[9px] opacity-60 text-center">Enter \u23CE to submit, Escape to cancel`);
var InputOverlay = (props) => {
  let containerRef;
  let inputRef;
  const position = useAnimatedPosition({
    x: () => props.x,
    y: () => props.y,
    lerpFactor: 0.3
  });
  const containerBoundingRect = () => containerRef?.getBoundingClientRect();
  const computedPosition = () => {
    const boundingRect = containerBoundingRect();
    if (!boundingRect) return {
      left: position.x(),
      top: position.y()
    };
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    const quadrants = getCursorQuadrants(position.x(), position.y(), boundingRect.width, boundingRect.height, CURSOR_OFFSET_PX);
    for (const position2 of quadrants) {
      const fitsHorizontally = position2.left >= VIEWPORT_MARGIN_PX && position2.left + boundingRect.width <= viewportWidth - VIEWPORT_MARGIN_PX;
      const fitsVertically = position2.top >= VIEWPORT_MARGIN_PX && position2.top + boundingRect.height <= viewportHeight - VIEWPORT_MARGIN_PX;
      if (fitsHorizontally && fitsVertically) {
        return position2;
      }
    }
    const fallback = getClampedElementPosition(quadrants[0].left, quadrants[0].top, boundingRect.width, boundingRect.height);
    fallback.left += INDICATOR_CLAMP_PADDING_PX;
    fallback.top += INDICATOR_CLAMP_PADDING_PX;
    return fallback;
  };
  const handleKeyDown = (event) => {
    if (event.code === "Enter" && !event.shiftKey) {
      event.preventDefault();
      event.stopPropagation();
      props.onSubmit();
    } else if (event.code === "Escape") {
      event.preventDefault();
      event.stopPropagation();
      props.onCancel();
    }
  };
  const handleInput = (event) => {
    const target = event.target;
    props.onInput(target.value);
  };
  createEffect(() => {
    if (props.visible && inputRef) {
      inputRef.focus();
    } else if (!props.visible && inputRef) {
      inputRef.blur();
    }
  });
  return (() => {
    var _el$ = _tmpl$8(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild;
    var _ref$ = containerRef;
    typeof _ref$ === "function" ? use(_ref$, _el$) : containerRef = _el$;
    _el$3.$$keydown = handleKeyDown;
    _el$3.$$input = handleInput;
    var _ref$2 = inputRef;
    typeof _ref$2 === "function" ? use(_ref$2, _el$3) : inputRef = _el$3;
    createRenderEffect((_p$) => {
      var _v$ = props.visible ? "block" : "none", _v$2 = `${computedPosition().top}px`, _v$3 = `${computedPosition().left}px`, _v$4 = props.zIndex?.toString() ?? "2147483647", _v$5 = props.visible ? "auto" : "none";
      _v$ !== _p$.e && setStyleProperty(_el$, "display", _p$.e = _v$);
      _v$2 !== _p$.t && setStyleProperty(_el$, "top", _p$.t = _v$2);
      _v$3 !== _p$.a && setStyleProperty(_el$, "left", _p$.a = _v$3);
      _v$4 !== _p$.o && setStyleProperty(_el$, "z-index", _p$.o = _v$4);
      _v$5 !== _p$.i && setStyleProperty(_el$, "pointer-events", _p$.i = _v$5);
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0,
      o: void 0,
      i: void 0
    });
    createRenderEffect(() => _el$3.value = props.value);
    return _el$;
  })();
};
delegateEvents(["input", "keydown"]);

// src/components/renderer.tsx
var ReactGrabRenderer = (props) => {
  return [createComponent(Show, {
    get when() {
      return memo(() => !!props.selectionVisible)() && props.selectionBounds;
    },
    get children() {
      return createComponent(SelectionBox, {
        variant: "selection",
        get bounds() {
          return props.selectionBounds;
        },
        get visible() {
          return props.selectionVisible;
        }
      });
    }
  }), createComponent(Show, {
    get when() {
      return memo(() => !!(props.crosshairVisible === true && props.mouseX !== void 0))() && props.mouseY !== void 0;
    },
    get children() {
      return createComponent(Crosshair, {
        get mouseX() {
          return props.mouseX;
        },
        get mouseY() {
          return props.mouseY;
        },
        visible: true
      });
    }
  }), createComponent(Show, {
    get when() {
      return memo(() => !!props.dragVisible)() && props.dragBounds;
    },
    get children() {
      return createComponent(SelectionBox, {
        variant: "drag",
        get bounds() {
          return props.dragBounds;
        },
        get visible() {
          return props.dragVisible;
        }
      });
    }
  }), createComponent(For, {
    get each() {
      return props.grabbedBoxes ?? [];
    },
    children: (box) => createComponent(SelectionBox, {
      variant: "grabbed",
      get bounds() {
        return box.bounds;
      },
      get createdAt() {
        return box.createdAt;
      }
    })
  }), createComponent(Show, {
    get when() {
      return props.labelVariant !== "processing";
    },
    get children() {
      return createComponent(For, {
        get each() {
          return props.successLabels ?? [];
        },
        children: (label) => createComponent(Label, {
          variant: "success",
          get content() {
            return memo(() => label.text);
          },
          get x() {
            return props.mouseX ?? 0;
          },
          get y() {
            return props.mouseY ?? 0;
          }
        })
      });
    }
  }), createComponent(Show, {
    get when() {
      return memo(() => !!(props.labelVisible && props.labelVariant && props.labelContent !== void 0 && props.labelX !== void 0))() && props.labelY !== void 0;
    },
    get children() {
      return createComponent(Label, {
        get variant() {
          return props.labelVariant;
        },
        get content() {
          return props.labelContent;
        },
        get x() {
          return props.labelX;
        },
        get y() {
          return props.labelY;
        },
        get visible() {
          return props.labelVisible;
        },
        get zIndex() {
          return props.labelZIndex;
        },
        get progress() {
          return props.progress;
        },
        get showHint() {
          return props.labelShowHint;
        }
      });
    }
  }), createComponent(InputOverlay, {
    get x() {
      return props.inputX ?? 0;
    },
    get y() {
      return props.inputY ?? 0;
    },
    get zIndex() {
      return props.labelZIndex;
    },
    get value() {
      return props.inputValue ?? "";
    },
    get visible() {
      return props.inputVisible ?? false;
    },
    get onInput() {
      return props.onInputChange;
    },
    get onSubmit() {
      return props.onInputSubmit;
    },
    get onCancel() {
      return props.onInputCancel;
    }
  })];
};

// ../../node_modules/.pnpm/bippy@0.5.16_@types+react@19.2.2_react@19.2.0/node_modules/bippy/dist/rdt-hook-CrcWl4lP.js
var e = `0.5.16`;
var t = `bippy-${e}`;
var n = Object.defineProperty;
var r2 = Object.prototype.hasOwnProperty;
var i = () => {
};
var a = (e2) => {
  try {
    let t2 = Function.prototype.toString.call(e2);
    t2.indexOf(`^_^`) > -1 && setTimeout(() => {
      throw Error(`React is running in production mode, but dead code elimination has not been applied. Read how to correctly configure React for production: https://reactjs.org/link/perf-use-production-build`);
    });
  } catch {
  }
};
var o = (e2 = h()) => `getFiberRoots` in e2;
var s = false;
var c;
var l = (e2 = h()) => s ? true : (typeof e2.inject == `function` && (c = e2.inject.toString()), !!c?.includes(`(injected)`));
var u = /* @__PURE__ */ new Set();
var d = /* @__PURE__ */ new Set();
var f = (e2) => {
  let r3 = /* @__PURE__ */ new Map(), o3 = 0, s3 = { _instrumentationIsActive: false, _instrumentationSource: t, checkDCE: a, hasUnsupportedRendererAttached: false, inject(e3) {
    let t2 = ++o3;
    return r3.set(t2, e3), d.add(e3), s3._instrumentationIsActive || (s3._instrumentationIsActive = true, u.forEach((e4) => e4())), t2;
  }, on: i, onCommitFiberRoot: i, onCommitFiberUnmount: i, onPostCommitFiberRoot: i, renderers: r3, supportsFiber: true, supportsFlight: true };
  try {
    n(globalThis, `__REACT_DEVTOOLS_GLOBAL_HOOK__`, { configurable: true, enumerable: true, get() {
      return s3;
    }, set(t3) {
      if (t3 && typeof t3 == `object`) {
        let n2 = s3.renderers;
        s3 = t3, n2.size > 0 && (n2.forEach((e3, n3) => {
          d.add(e3), t3.renderers.set(n3, e3);
        }), p(e2));
      }
    } });
    let t2 = window.hasOwnProperty, r4 = false;
    n(window, `hasOwnProperty`, { configurable: true, value: function(...e3) {
      try {
        if (!r4 && e3[0] === `__REACT_DEVTOOLS_GLOBAL_HOOK__`) return globalThis.__REACT_DEVTOOLS_GLOBAL_HOOK__ = void 0, r4 = true, -0;
      } catch {
      }
      return t2.apply(this, e3);
    }, writable: true });
  } catch {
    p(e2);
  }
  return s3;
};
var p = (e2) => {
  try {
    let n2 = globalThis.__REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!n2) return;
    if (!n2._instrumentationSource) {
      n2.checkDCE = a, n2.supportsFiber = true, n2.supportsFlight = true, n2.hasUnsupportedRendererAttached = false, n2._instrumentationSource = t, n2._instrumentationIsActive = false;
      let e3 = o(n2);
      if (e3 || (n2.on = i), n2.renderers.size) {
        n2._instrumentationIsActive = true, u.forEach((e4) => e4());
        return;
      }
      let r3 = n2.inject, c3 = l(n2);
      if (c3 && !e3) {
        s = true;
        let e4 = n2.inject({ scheduleRefresh() {
        } });
        e4 && (n2._instrumentationIsActive = true);
      }
      n2.inject = (e4) => {
        let t2 = r3(e4);
        return d.add(e4), c3 && n2.renderers.set(t2, e4), n2._instrumentationIsActive = true, u.forEach((e5) => e5()), t2;
      };
    }
    (n2.renderers.size || n2._instrumentationIsActive || l()) && e2?.();
  } catch {
  }
};
var m = () => r2.call(globalThis, `__REACT_DEVTOOLS_GLOBAL_HOOK__`);
var h = (e2) => m() ? (p(e2), globalThis.__REACT_DEVTOOLS_GLOBAL_HOOK__) : f(e2);
var g = () => !!(typeof window < `u` && (window.document?.createElement || window.navigator?.product === `ReactNative`));
var _ = () => {
  try {
    g() && h();
  } catch {
  }
};

// ../../node_modules/.pnpm/bippy@0.5.16_@types+react@19.2.2_react@19.2.0/node_modules/bippy/dist/install-hook-only-DtUPvEBg.js
_();

// ../../node_modules/.pnpm/bippy@0.5.16_@types+react@19.2.2_react@19.2.0/node_modules/bippy/dist/core-D7_ABaNC.js
var a2 = 0;
var o2 = 1;
var c2 = 5;
var f2 = 11;
var p2 = 13;
var m2 = 14;
var h2 = 15;
var ee = 16;
var te = 19;
var y = 26;
var b = 27;
var ne = 28;
var re = 30;
var k = (e2) => {
  switch (e2.tag) {
    case c2:
    case y:
    case b:
      return true;
    default:
      return typeof e2.type == `string`;
  }
};
var pe = (e2) => {
  switch (e2.tag) {
    case o2:
    case f2:
    case a2:
    case m2:
    case h2:
      return true;
    default:
      return false;
  }
};
var me = (e2) => !e2 || typeof e2 != `object` ? true : `pendingProps` in e2 && !(`containerInfo` in e2);
function N(e2, t2, n2 = false) {
  if (!e2) return null;
  let r3 = t2(e2);
  if (r3 instanceof Promise) return (async () => {
    if (await r3 === true) return e2;
    let i3 = n2 ? e2.return : e2.child;
    for (; i3; ) {
      let e3 = await F(i3, t2, n2);
      if (e3) return e3;
      i3 = n2 ? null : i3.sibling;
    }
    return null;
  })();
  if (r3 === true) return e2;
  let i2 = n2 ? e2.return : e2.child;
  for (; i2; ) {
    let e3 = P(i2, t2, n2);
    if (e3) return e3;
    i2 = n2 ? null : i2.sibling;
  }
  return null;
}
var P = (e2, t2, n2 = false) => {
  if (!e2) return null;
  if (t2(e2) === true) return e2;
  let r3 = n2 ? e2.return : e2.child;
  for (; r3; ) {
    let e3 = P(r3, t2, n2);
    if (e3) return e3;
    r3 = n2 ? null : r3.sibling;
  }
  return null;
};
var F = async (e2, t2, n2 = false) => {
  if (!e2) return null;
  if (await t2(e2) === true) return e2;
  let r3 = n2 ? e2.return : e2.child;
  for (; r3; ) {
    let e3 = await F(r3, t2, n2);
    if (e3) return e3;
    r3 = n2 ? null : r3.sibling;
  }
  return null;
};
var I = (e2) => {
  let t2 = e2;
  return typeof t2 == `function` ? t2 : typeof t2 == `object` && t2 ? I(t2.type || t2.render) : null;
};
var Te = (e2) => {
  let t2 = e2;
  if (typeof t2 == `string`) return t2;
  if (typeof t2 != `function` && !(typeof t2 == `object` && t2)) return null;
  let n2 = t2.displayName || t2.name || null;
  if (n2) return n2;
  let r3 = I(t2);
  return r3 && (r3.displayName || r3.name) || null;
};
var Ee = () => {
  let e2 = h();
  return !!e2._instrumentationIsActive || o() || l();
};
var De = (e2) => {
  let t2 = e2.alternate;
  if (!t2) return e2;
  if (t2.actualStartTime && e2.actualStartTime) return t2.actualStartTime > e2.actualStartTime ? t2 : e2;
  for (let t3 of $) {
    let n2 = N(t3.current, (t4) => {
      if (t4 === e2) return true;
    });
    if (n2) return n2;
  }
  return e2;
};
var Pe = (e2) => {
  let n2 = h();
  for (let t2 of n2.renderers.values()) try {
    let n3 = t2.findFiberByHostInstance?.(e2);
    if (n3) return n3;
  } catch {
  }
  if (typeof e2 == `object` && e2) {
    if (`_reactRootContainer` in e2) return e2._reactRootContainer?._internalRoot?.current?.child;
    for (let t2 in e2) if (t2.startsWith(`__reactContainer$`) || t2.startsWith(`__reactInternalInstance$`) || t2.startsWith(`__reactFiber`)) return e2[t2] || null;
  }
  return null;
};
var $ = /* @__PURE__ */ new Set();

// ../../node_modules/.pnpm/bippy@0.5.16_@types+react@19.2.2_react@19.2.0/node_modules/bippy/dist/source.js
var b2 = Object.create;
var x2 = Object.defineProperty;
var S2 = Object.getOwnPropertyDescriptor;
var C2 = Object.getOwnPropertyNames;
var ee2 = Object.getPrototypeOf;
var te2 = Object.prototype.hasOwnProperty;
var ne2 = (e2, t2) => () => (t2 || e2((t2 = { exports: {} }).exports, t2), t2.exports);
var re2 = (e2, t2, n2, r3) => {
  if (t2 && typeof t2 == `object` || typeof t2 == `function`) for (var i2 = C2(t2), a3 = 0, o3 = i2.length, s3; a3 < o3; a3++) s3 = i2[a3], !te2.call(e2, s3) && s3 !== n2 && x2(e2, s3, { get: ((e3) => t2[e3]).bind(null, s3), enumerable: !(r3 = S2(t2, s3)) || r3.enumerable });
  return e2;
};
var ie2 = (e2, t2, n2) => (n2 = e2 == null ? {} : b2(ee2(e2)), re2(x2(n2, `default`, { value: e2, enumerable: true }) , e2));
var ae2 = () => {
  let n2 = h();
  for (let t2 of [...Array.from(d), ...Array.from(n2.renderers.values())]) {
    let e2 = t2.currentDispatcherRef;
    if (e2 && typeof e2 == `object`) return `H` in e2 ? e2.H : e2.current;
  }
  return null;
};
var w2 = (t2) => {
  for (let n2 of d) {
    let e2 = n2.currentDispatcherRef;
    e2 && typeof e2 == `object` && (`H` in e2 ? e2.H = t2 : e2.current = t2);
  }
};
var T2 = (e2) => `
    in ${e2}`;
var oe2 = (e2, t2) => {
  let n2 = T2(e2);
  return t2 && (n2 += ` (at ${t2})`), n2;
};
var E = false;
var D = (e2, t2) => {
  if (!e2 || E) return ``;
  let n2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0, E = true;
  let r3 = ae2();
  w2(null);
  let i2 = console.error, a3 = console.warn;
  console.error = () => {
  }, console.warn = () => {
  };
  try {
    let n3 = { DetermineComponentFrameRoot() {
      let n4;
      try {
        if (t2) {
          let t3 = function() {
            throw Error();
          };
          if (Object.defineProperty(t3.prototype, `props`, { set: function() {
            throw Error();
          } }), typeof Reflect == `object` && Reflect.construct) {
            try {
              Reflect.construct(t3, []);
            } catch (e3) {
              n4 = e3;
            }
            Reflect.construct(e2, [], t3);
          } else {
            try {
              t3.call();
            } catch (e3) {
              n4 = e3;
            }
            e2.call(t3.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (e3) {
            n4 = e3;
          }
          let t3 = e2();
          t3 && typeof t3.catch == `function` && t3.catch(() => {
          });
        }
      } catch (e3) {
        if (e3 instanceof Error && n4 instanceof Error && typeof e3.stack == `string`) return [e3.stack, n4.stack];
      }
      return [null, null];
    } };
    n3.DetermineComponentFrameRoot.displayName = `DetermineComponentFrameRoot`;
    let r4 = Object.getOwnPropertyDescriptor(n3.DetermineComponentFrameRoot, `name`);
    r4?.configurable && Object.defineProperty(n3.DetermineComponentFrameRoot, `name`, { value: `DetermineComponentFrameRoot` });
    let [i3, a4] = n3.DetermineComponentFrameRoot();
    if (i3 && a4) {
      let t3 = i3.split(`
`), n4 = a4.split(`
`), r5 = 0, o4 = 0;
      for (; r5 < t3.length && !t3[r5].includes(`DetermineComponentFrameRoot`); ) r5++;
      for (; o4 < n4.length && !n4[o4].includes(`DetermineComponentFrameRoot`); ) o4++;
      if (r5 === t3.length || o4 === n4.length) for (r5 = t3.length - 1, o4 = n4.length - 1; r5 >= 1 && o4 >= 0 && t3[r5] !== n4[o4]; ) o4--;
      for (; r5 >= 1 && o4 >= 0; r5--, o4--) if (t3[r5] !== n4[o4]) {
        if (r5 !== 1 || o4 !== 1) do
          if (r5--, o4--, o4 < 0 || t3[r5] !== n4[o4]) {
            let n5 = `
${t3[r5].replace(` at new `, ` at `)}`, i4 = Te(e2);
            return i4 && n5.includes(`<anonymous>`) && (n5 = n5.replace(`<anonymous>`, i4)), n5;
          }
        while (r5 >= 1 && o4 >= 0);
        break;
      }
    }
  } finally {
    E = false, Error.prepareStackTrace = n2, w2(r3), console.error = i2, console.warn = a3;
  }
  let o3 = e2 ? Te(e2) : ``, s3 = o3 ? T2(o3) : ``;
  return s3;
};
var se2 = (e2, t2) => {
  let m3 = e2.tag, h3 = ``;
  switch (m3) {
    case ne:
      h3 = T2(`Activity`);
      break;
    case o2:
      h3 = D(e2.type, true);
      break;
    case f2:
      h3 = D(e2.type.render, false);
      break;
    case a2:
    case h2:
      h3 = D(e2.type, false);
      break;
    case c2:
    case y:
    case b:
      h3 = T2(e2.type);
      break;
    case ee:
      h3 = T2(`Lazy`);
      break;
    case p2:
      h3 = e2.child !== t2 && t2 !== null ? T2(`Suspense Fallback`) : T2(`Suspense`);
      break;
    case te:
      h3 = T2(`SuspenseList`);
      break;
    case re:
      h3 = T2(`ViewTransition`);
      break;
    default:
      return ``;
  }
  return h3;
};
var ce2 = (e2) => {
  try {
    let t2 = ``, n2 = e2, r3 = null;
    do {
      t2 += se2(n2, r3);
      let e3 = n2._debugInfo;
      if (e3 && Array.isArray(e3)) for (let n3 = e3.length - 1; n3 >= 0; n3--) {
        let r4 = e3[n3];
        typeof r4.name == `string` && (t2 += oe2(r4.name, r4.env));
      }
      r3 = n2, n2 = n2.return;
    } while (n2);
    return t2;
  } catch (e3) {
    return e3 instanceof Error ? `
Error generating stack: ${e3.message}
${e3.stack}` : ``;
  }
};
var O2 = (e2) => {
  let t2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  let n2 = e2;
  if (!n2) return ``;
  Error.prepareStackTrace = t2, n2.startsWith(`Error: react-stack-top-frame
`) && (n2 = n2.slice(29));
  let r3 = n2.indexOf(`
`);
  if (r3 !== -1 && (n2 = n2.slice(r3 + 1)), r3 = Math.max(n2.indexOf(`react_stack_bottom_frame`), n2.indexOf(`react-stack-bottom-frame`)), r3 !== -1 && (r3 = n2.lastIndexOf(`
`, r3)), r3 !== -1) n2 = n2.slice(0, r3);
  else return ``;
  return n2;
};
var k2 = /(^|@)\S+:\d+/;
var A2 = /^\s*at .*(\S+:\d+|\(native\))/m;
var le2 = /^(eval@)?(\[native code\])?$/;
var M2 = (e2, t2) => {
  if (t2?.includeInElement !== false) {
    let n2 = e2.split(`
`), r3 = [];
    for (let e3 of n2) if (/^\s*at\s+/.test(e3)) {
      let t3 = F2(e3, void 0)[0];
      t3 && r3.push(t3);
    } else if (/^\s*in\s+/.test(e3)) {
      let t3 = e3.replace(/^\s*in\s+/, ``).replace(/\s*\(at .*\)$/, ``);
      r3.push({ function: t3, raw: e3 });
    } else if (e3.match(k2)) {
      let t3 = I2(e3, void 0)[0];
      t3 && r3.push(t3);
    }
    return P2(r3, t2);
  }
  return e2.match(A2) ? F2(e2, t2) : I2(e2, t2);
};
var N2 = (e2) => {
  if (!e2.includes(`:`)) return [e2, void 0, void 0];
  let t2 = /(.+?)(?::(\d+))?(?::(\d+))?$/, n2 = t2.exec(e2.replace(/[()]/g, ``));
  return [n2[1], n2[2] || void 0, n2[3] || void 0];
};
var P2 = (e2, t2) => t2 && t2.slice != null ? Array.isArray(t2.slice) ? e2.slice(t2.slice[0], t2.slice[1]) : e2.slice(0, t2.slice) : e2;
var F2 = (e2, t2) => {
  let n2 = P2(e2.split(`
`).filter((e3) => !!e3.match(A2)), t2);
  return n2.map((e3) => {
    let t3 = e3;
    t3.includes(`(eval `) && (t3 = t3.replace(/eval code/g, `eval`).replace(/(\(eval at [^()]*)|(,.*$)/g, ``));
    let n3 = t3.replace(/^\s+/, ``).replace(/\(eval code/g, `(`).replace(/^.*?\s+/, ``), r3 = n3.match(/ (\(.+\)$)/);
    n3 = r3 ? n3.replace(r3[0], ``) : n3;
    let i2 = N2(r3 ? r3[1] : n3), a3 = r3 && n3 || void 0, o3 = [`eval`, `<anonymous>`].includes(i2[0]) ? void 0 : i2[0];
    return { function: a3, file: o3, line: i2[1] ? +i2[1] : void 0, col: i2[2] ? +i2[2] : void 0, raw: t3 };
  });
};
var I2 = (e2, t2) => {
  let n2 = P2(e2.split(`
`).filter((e3) => !e3.match(le2)), t2);
  return n2.map((e3) => {
    let t3 = e3;
    if (t3.includes(` > eval`) && (t3 = t3.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, `:$1`)), !t3.includes(`@`) && !t3.includes(`:`)) return { function: t3 };
    {
      let e4 = /(([^\n\r"\u2028\u2029]*".[^\n\r"\u2028\u2029]*"[^\n\r@\u2028\u2029]*(?:@[^\n\r"\u2028\u2029]*"[^\n\r@\u2028\u2029]*)*(?:[\n\r\u2028\u2029][^@]*)?)?[^@]*)@/, n3 = t3.match(e4), r3 = n3 && n3[1] ? n3[1] : void 0, i2 = N2(t3.replace(e4, ``));
      return { function: r3, file: i2[0], line: i2[1] ? +i2[1] : void 0, col: i2[2] ? +i2[2] : void 0, raw: t3 };
    }
  });
};
var pe2 = ne2((exports, t2) => {
  (function(n2, r3) {
    typeof exports == `object` && t2 !== void 0 ? r3(exports) : typeof define == `function` && define.amd ? define([`exports`], r3) : (n2 = typeof globalThis < `u` ? globalThis : n2 || self, r3(n2.sourcemapCodec = {}));
  })(void 0, function(e2) {
    let t3 = 44, n2 = 59, r3 = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/`, i2 = new Uint8Array(64), a3 = new Uint8Array(128);
    for (let e3 = 0; e3 < r3.length; e3++) {
      let t4 = r3.charCodeAt(e3);
      i2[e3] = t4, a3[t4] = e3;
    }
    function o3(e3, t4) {
      let n3 = 0, r4 = 0, i3 = 0;
      do {
        let t5 = e3.next();
        i3 = a3[t5], n3 |= (i3 & 31) << r4, r4 += 5;
      } while (i3 & 32);
      let o4 = n3 & 1;
      return n3 >>>= 1, o4 && (n3 = -2147483648 | -n3), t4 + n3;
    }
    function s3(e3, t4, n3) {
      let r4 = t4 - n3;
      r4 = r4 < 0 ? -r4 << 1 | 1 : r4 << 1;
      do {
        let t5 = r4 & 31;
        r4 >>>= 5, r4 > 0 && (t5 |= 32), e3.write(i2[t5]);
      } while (r4 > 0);
      return t4;
    }
    function c3(e3, n3) {
      return e3.pos >= n3 ? false : e3.peek() !== t3;
    }
    let l3 = 1024 * 16, u3 = typeof TextDecoder < `u` ? new TextDecoder() : typeof Buffer < `u` ? { decode(e3) {
      let t4 = Buffer.from(e3.buffer, e3.byteOffset, e3.byteLength);
      return t4.toString();
    } } : { decode(e3) {
      let t4 = ``;
      for (let n3 = 0; n3 < e3.length; n3++) t4 += String.fromCharCode(e3[n3]);
      return t4;
    } };
    class d3 {
      constructor() {
        this.pos = 0, this.out = ``, this.buffer = new Uint8Array(l3);
      }
      write(e3) {
        let { buffer: t4 } = this;
        t4[this.pos++] = e3, this.pos === l3 && (this.out += u3.decode(t4), this.pos = 0);
      }
      flush() {
        let { buffer: e3, out: t4, pos: n3 } = this;
        return n3 > 0 ? t4 + u3.decode(e3.subarray(0, n3)) : t4;
      }
    }
    class f3 {
      constructor(e3) {
        this.pos = 0, this.buffer = e3;
      }
      next() {
        return this.buffer.charCodeAt(this.pos++);
      }
      peek() {
        return this.buffer.charCodeAt(this.pos);
      }
      indexOf(e3) {
        let { buffer: t4, pos: n3 } = this, r4 = t4.indexOf(e3, n3);
        return r4 === -1 ? t4.length : r4;
      }
    }
    let p3 = [];
    function m3(e3) {
      let { length: t4 } = e3, n3 = new f3(e3), r4 = [], i3 = [], a4 = 0;
      for (; n3.pos < t4; n3.pos++) {
        a4 = o3(n3, a4);
        let e4 = o3(n3, 0);
        if (!c3(n3, t4)) {
          let t5 = i3.pop();
          t5[2] = a4, t5[3] = e4;
          continue;
        }
        let s4 = o3(n3, 0), l4 = o3(n3, 0), u4 = l4 & 1, d4 = u4 ? [a4, e4, 0, 0, s4, o3(n3, 0)] : [a4, e4, 0, 0, s4], f4 = p3;
        if (c3(n3, t4)) {
          f4 = [];
          do {
            let e5 = o3(n3, 0);
            f4.push(e5);
          } while (c3(n3, t4));
        }
        d4.vars = f4, r4.push(d4), i3.push(d4);
      }
      return r4;
    }
    function h3(e3) {
      let t4 = new d3();
      for (let n3 = 0; n3 < e3.length; ) n3 = g3(e3, n3, t4, [0]);
      return t4.flush();
    }
    function g3(e3, n3, r4, i3) {
      let a4 = e3[n3], { 0: o4, 1: c4, 2: l4, 3: u4, 4: d4, vars: f4 } = a4;
      n3 > 0 && r4.write(t3), i3[0] = s3(r4, o4, i3[0]), s3(r4, c4, 0), s3(r4, d4, 0);
      let p4 = a4.length === 6 ? 1 : 0;
      s3(r4, p4, 0), a4.length === 6 && s3(r4, a4[5], 0);
      for (let e4 of f4) s3(r4, e4, 0);
      for (n3++; n3 < e3.length; ) {
        let t4 = e3[n3], { 0: a5, 1: o5 } = t4;
        if (a5 > l4 || a5 === l4 && o5 >= u4) break;
        n3 = g3(e3, n3, r4, i3);
      }
      return r4.write(t3), i3[0] = s3(r4, l4, i3[0]), s3(r4, u4, 0), n3;
    }
    function _3(e3) {
      let { length: t4 } = e3, n3 = new f3(e3), r4 = [], i3 = [], a4 = 0, s4 = 0, l4 = 0, u4 = 0, d4 = 0, m4 = 0, h4 = 0, g4 = 0;
      do {
        let e4 = n3.indexOf(`;`), t5 = 0;
        for (; n3.pos < e4; n3.pos++) {
          if (t5 = o3(n3, t5), !c3(n3, e4)) {
            let e5 = i3.pop();
            e5[2] = a4, e5[3] = t5;
            continue;
          }
          let f4 = o3(n3, 0), _4 = f4 & 1, v3 = f4 & 2, y3 = f4 & 4, b4 = null, x4 = p3, S4;
          if (_4) {
            let e5 = o3(n3, s4);
            l4 = o3(n3, s4 === e5 ? l4 : 0), s4 = e5, S4 = [a4, t5, 0, 0, e5, l4];
          } else S4 = [a4, t5, 0, 0];
          if (S4.isScope = !!y3, v3) {
            let e5 = u4, t6 = d4;
            u4 = o3(n3, u4);
            let r5 = e5 === u4;
            d4 = o3(n3, r5 ? d4 : 0), m4 = o3(n3, r5 && t6 === d4 ? m4 : 0), b4 = [u4, d4, m4];
          }
          if (S4.callsite = b4, c3(n3, e4)) {
            x4 = [];
            do {
              h4 = a4, g4 = t5;
              let e5 = o3(n3, 0), r5;
              if (e5 < -1) {
                r5 = [[o3(n3, 0)]];
                for (let t6 = -1; t6 > e5; t6--) {
                  let e6 = h4;
                  h4 = o3(n3, h4), g4 = o3(n3, h4 === e6 ? g4 : 0);
                  let t7 = o3(n3, 0);
                  r5.push([t7, h4, g4]);
                }
              } else r5 = [[e5]];
              x4.push(r5);
            } while (c3(n3, e4));
          }
          S4.bindings = x4, r4.push(S4), i3.push(S4);
        }
        a4++, n3.pos = e4 + 1;
      } while (n3.pos < t4);
      return r4;
    }
    function v2(e3) {
      if (e3.length === 0) return ``;
      let t4 = new d3();
      for (let n3 = 0; n3 < e3.length; ) n3 = y2(e3, n3, t4, [0, 0, 0, 0, 0, 0, 0]);
      return t4.flush();
    }
    function y2(e3, n3, r4, i3) {
      let a4 = e3[n3], { 0: o4, 1: c4, 2: l4, 3: u4, isScope: d4, callsite: f4, bindings: p4 } = a4;
      i3[0] < o4 ? (b3(r4, i3[0], o4), i3[0] = o4, i3[1] = 0) : n3 > 0 && r4.write(t3), i3[1] = s3(r4, a4[1], i3[1]);
      let m4 = (a4.length === 6 ? 1 : 0) | (f4 ? 2 : 0) | (d4 ? 4 : 0);
      if (s3(r4, m4, 0), a4.length === 6) {
        let { 4: e4, 5: t4 } = a4;
        e4 !== i3[2] && (i3[3] = 0), i3[2] = s3(r4, e4, i3[2]), i3[3] = s3(r4, t4, i3[3]);
      }
      if (f4) {
        let { 0: e4, 1: t4, 2: n4 } = a4.callsite;
        e4 === i3[4] ? t4 !== i3[5] && (i3[6] = 0) : (i3[5] = 0, i3[6] = 0), i3[4] = s3(r4, e4, i3[4]), i3[5] = s3(r4, t4, i3[5]), i3[6] = s3(r4, n4, i3[6]);
      }
      if (p4) for (let e4 of p4) {
        e4.length > 1 && s3(r4, -e4.length, 0);
        let t4 = e4[0][0];
        s3(r4, t4, 0);
        let n4 = o4, i4 = c4;
        for (let t5 = 1; t5 < e4.length; t5++) {
          let a5 = e4[t5];
          n4 = s3(r4, a5[1], n4), i4 = s3(r4, a5[2], i4), s3(r4, a5[0], 0);
        }
      }
      for (n3++; n3 < e3.length; ) {
        let t4 = e3[n3], { 0: a5, 1: o5 } = t4;
        if (a5 > l4 || a5 === l4 && o5 >= u4) break;
        n3 = y2(e3, n3, r4, i3);
      }
      return i3[0] < l4 ? (b3(r4, i3[0], l4), i3[0] = l4, i3[1] = 0) : r4.write(t3), i3[1] = s3(r4, u4, i3[1]), n3;
    }
    function b3(e3, t4, r4) {
      do
        e3.write(n2);
      while (++t4 < r4);
    }
    function x3(e3) {
      let { length: t4 } = e3, n3 = new f3(e3), r4 = [], i3 = 0, a4 = 0, s4 = 0, l4 = 0, u4 = 0;
      do {
        let e4 = n3.indexOf(`;`), t5 = [], d4 = true, f4 = 0;
        for (i3 = 0; n3.pos < e4; ) {
          let r5;
          i3 = o3(n3, i3), i3 < f4 && (d4 = false), f4 = i3, c3(n3, e4) ? (a4 = o3(n3, a4), s4 = o3(n3, s4), l4 = o3(n3, l4), c3(n3, e4) ? (u4 = o3(n3, u4), r5 = [i3, a4, s4, l4, u4]) : r5 = [i3, a4, s4, l4]) : r5 = [i3], t5.push(r5), n3.pos++;
        }
        d4 || S3(t5), r4.push(t5), n3.pos = e4 + 1;
      } while (n3.pos <= t4);
      return r4;
    }
    function S3(e3) {
      e3.sort(C3);
    }
    function C3(e3, t4) {
      return e3[0] - t4[0];
    }
    function ee3(e3) {
      let r4 = new d3(), i3 = 0, a4 = 0, o4 = 0, c4 = 0;
      for (let l4 = 0; l4 < e3.length; l4++) {
        let u4 = e3[l4];
        if (l4 > 0 && r4.write(n2), u4.length === 0) continue;
        let d4 = 0;
        for (let e4 = 0; e4 < u4.length; e4++) {
          let n3 = u4[e4];
          e4 > 0 && r4.write(t3), d4 = s3(r4, n3[0], d4), n3.length !== 1 && (i3 = s3(r4, n3[1], i3), a4 = s3(r4, n3[2], a4), o4 = s3(r4, n3[3], o4), n3.length !== 4 && (c4 = s3(r4, n3[4], c4)));
        }
      }
      return r4.flush();
    }
    e2.decode = x3, e2.decodeGeneratedRanges = _3, e2.decodeOriginalScopes = m3, e2.encode = ee3, e2.encodeGeneratedRanges = v2, e2.encodeOriginalScopes = h3, Object.defineProperty(e2, `__esModule`, { value: true });
  });
});
var B2 = ie2(pe2());
var V2 = /^[a-zA-Z][a-zA-Z\d+\-.]*:/;
var me2 = /^data:application\/json[^,]+base64,/;
var he2 = /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*(?:\*\/)[ \t]*$)/;
var H2 = typeof WeakRef < `u`;
var U2 = /* @__PURE__ */ new Map();
var W2 = /* @__PURE__ */ new Map();
var ge2 = (e2) => H2 && e2 instanceof WeakRef;
var G2 = (e2, t2, n2, r3) => {
  if (n2 < 0 || n2 >= e2.length) return null;
  let i2 = e2[n2];
  if (!i2 || i2.length === 0) return null;
  let a3 = null;
  for (let e3 of i2) if (e3[0] <= r3) a3 = e3;
  else break;
  if (!a3 || a3.length < 4) return null;
  let [, o3, s3, c3] = a3;
  if (o3 === void 0 || s3 === void 0 || c3 === void 0) return null;
  let l3 = t2[o3];
  return l3 ? { columnNumber: c3, fileName: l3, lineNumber: s3 + 1 } : null;
};
var K = (e2, t2, n2) => {
  if (e2.sections) {
    let r3 = null;
    for (let i3 of e2.sections) if (t2 > i3.offset.line || t2 === i3.offset.line && n2 >= i3.offset.column) r3 = i3;
    else break;
    if (!r3) return null;
    let i2 = t2 - r3.offset.line, a3 = t2 === r3.offset.line ? n2 - r3.offset.column : n2;
    return G2(r3.map.mappings, r3.map.sources, i2, a3);
  }
  return G2(e2.mappings, e2.sources, t2 - 1, n2);
};
var _e2 = (e2, t2) => {
  let n2 = t2.split(`
`), r3;
  for (let e3 = n2.length - 1; e3 >= 0 && !r3; e3--) {
    let t3 = n2[e3].match(he2);
    t3 && (r3 = t3[1] || t3[2]);
  }
  if (!r3) return null;
  let i2 = V2.test(r3);
  if (!(me2.test(r3) || i2 || r3.startsWith(`/`))) {
    let t3 = e2.split(`/`);
    t3[t3.length - 1] = r3, r3 = t3.join(`/`);
  }
  return r3;
};
var ve2 = (e2) => ({ file: e2.file, mappings: (0, B2.decode)(e2.mappings), names: e2.names, sourceRoot: e2.sourceRoot, sources: e2.sources, sourcesContent: e2.sourcesContent, version: 3 });
var ye2 = (e2) => {
  let t2 = e2.sections.map(({ map: e3, offset: t3 }) => ({ map: { ...e3, mappings: (0, B2.decode)(e3.mappings) }, offset: t3 })), n2 = /* @__PURE__ */ new Set();
  for (let e3 of t2) for (let t3 of e3.map.sources) n2.add(t3);
  return { file: e2.file, mappings: [], names: [], sections: t2, sourceRoot: void 0, sources: Array.from(n2), sourcesContent: void 0, version: 3 };
};
var q = (e2) => {
  if (!e2) return false;
  let t2 = e2.trim();
  if (!t2) return false;
  let n2 = t2.match(V2);
  if (!n2) return true;
  let r3 = n2[0].toLowerCase();
  return r3 === `http:` || r3 === `https:`;
};
var J = async (e2, t2 = fetch) => {
  if (!q(e2)) return null;
  let n2;
  try {
    let r4 = await t2(e2);
    n2 = await r4.text();
  } catch {
    return null;
  }
  if (!n2) return null;
  let r3 = _e2(e2, n2);
  if (!r3 || !q(r3)) return null;
  try {
    let e3 = await t2(r3), n3 = await e3.json();
    return `sections` in n3 ? ye2(n3) : ve2(n3);
  } catch {
    return null;
  }
};
var Y = async (e2, t2 = true, n2) => {
  if (t2 && U2.has(e2)) {
    let t3 = U2.get(e2);
    if (t3 == null) return null;
    if (ge2(t3)) {
      let n3 = t3.deref();
      if (n3) return n3;
      U2.delete(e2);
    } else return t3;
  }
  if (t2 && W2.has(e2)) return W2.get(e2);
  let r3 = J(e2, n2);
  t2 && W2.set(e2, r3);
  let i2 = await r3;
  return t2 && W2.delete(e2), t2 && (i2 === null ? U2.set(e2, null) : U2.set(e2, H2 ? new WeakRef(i2) : i2)), i2;
};
var be2 = /^[a-zA-Z][a-zA-Z\d+\-.]*:/;
var xe2 = [`rsc://`, `file:///`, `webpack://`, `node:`, `turbopack://`, `metro://`];
var Se2 = `about://React/`;
var Ce2 = [`<anonymous>`, `eval`, ``];
var we2 = /\.(jsx|tsx|ts|js)$/;
var Te2 = /(\.min|bundle|chunk|vendor|vendors|runtime|polyfill|polyfills)\.(js|mjs|cjs)$|(chunk|bundle|vendor|vendors|runtime|polyfill|polyfills|framework|app|main|index)[-_.][A-Za-z0-9_-]{4,}\.(js|mjs|cjs)$|[\da-f]{8,}\.(js|mjs|cjs)$|[-_.][\da-f]{20,}\.(js|mjs|cjs)$|\/dist\/|\/build\/|\/.next\/|\/out\/|\/node_modules\/|\.webpack\.|\.vite\.|\.turbopack\./i;
var Ee2 = /^\?[\w~.\-]+(?:=[^&#]*)?(?:&[\w~.\-]+(?:=[^&#]*)?)*$/;
var De2 = (e2) => e2._debugStack instanceof Error && typeof e2._debugStack?.stack == `string`;
var Oe = (e2) => {
  let t2 = e2._debugSource;
  return t2 ? typeof t2 == `object` && !!t2 && `fileName` in t2 && typeof t2.fileName == `string` && `lineNumber` in t2 && typeof t2.lineNumber == `number` : false;
};
var ke2 = async (e2, t2 = true, n2) => {
  if (Oe(e2)) {
    let t3 = e2._debugSource;
    return t3 || null;
  }
  let r3 = X2(e2), i2 = await Z(r3, 1, t2, n2);
  return !i2 || i2.length === 0 ? null : i2[0];
};
var X2 = (e2) => De2(e2) ? O2(e2._debugStack.stack) : ce2(e2);
var Z = async (e2, t2 = 1, n2 = true, r3) => {
  let i2 = M2(e2, { slice: t2 ?? 1 }), a3 = [];
  for (let e3 of i2) {
    if (!e3?.file) continue;
    let t3 = await Y(e3.file, n2, r3);
    if (t3 && typeof e3.line == `number` && typeof e3.col == `number`) {
      let n3 = K(t3, e3.line, e3.col);
      if (n3) {
        a3.push(n3);
        continue;
      }
    }
    a3.push({ fileName: e3.file, lineNumber: e3.line, columnNumber: e3.col, functionName: e3.function });
  }
  return a3;
};
var Q = (e2) => {
  if (!e2 || Ce2.includes(e2)) return ``;
  let t2 = e2;
  if (t2.startsWith(Se2)) {
    let e3 = t2.slice(Se2.length), n3 = e3.indexOf(`/`), r3 = e3.indexOf(`:`);
    t2 = n3 !== -1 && (r3 === -1 || n3 < r3) ? e3.slice(n3 + 1) : e3;
  }
  for (let e3 of xe2) if (t2.startsWith(e3)) {
    t2 = t2.slice(e3.length), e3 === `file:///` && (t2 = `/${t2.replace(/^\/+/, ``)}`);
    break;
  }
  if (be2.test(t2)) {
    let e3 = t2.match(be2);
    e3 && (t2 = t2.slice(e3[0].length));
  }
  let n2 = t2.indexOf(`?`);
  if (n2 !== -1) {
    let e3 = t2.slice(n2);
    Ee2.test(e3) && (t2 = t2.slice(0, n2));
  }
  return t2;
};
var je2 = (e2) => {
  let t2 = Q(e2);
  return !(!t2 || !we2.test(t2) || Te2.test(t2));
};

// src/utils/is-capitalized.ts
var isCapitalized = (value) => value.length > 0 && /^[A-Z]/.test(value);

// src/instrumentation.ts
var NEXT_INTERNAL_COMPONENT_NAMES = [
  "InnerLayoutRouter",
  "RedirectErrorBoundary",
  "RedirectBoundary",
  "HTTPAccessFallbackErrorBoundary",
  "HTTPAccessFallbackBoundary",
  "LoadingBoundary",
  "ErrorBoundary",
  "InnerScrollAndFocusHandler",
  "ScrollAndFocusHandler",
  "RenderFromTemplateContext",
  "OuterLayoutRouter",
  "body",
  "html",
  "RedirectErrorBoundary",
  "RedirectBoundary",
  "HTTPAccessFallbackErrorBoundary",
  "HTTPAccessFallbackBoundary",
  "DevRootHTTPAccessFallbackBoundary",
  "AppDevOverlayErrorBoundary",
  "AppDevOverlay",
  "HotReload",
  "Router",
  "ErrorBoundaryHandler",
  "ErrorBoundary",
  "AppRouter",
  "ServerRoot",
  "SegmentStateProvider",
  "RootErrorBoundary"
];
var checkIsNextProject = () => {
  return Boolean(document.getElementById("__NEXT_DATA__"));
};
var checkIsInternalComponentName = (name) => {
  if (name.startsWith("_")) return true;
  if (NEXT_INTERNAL_COMPONENT_NAMES.includes(name)) return true;
  return false;
};
var checkIsSourceComponentName = (name) => {
  if (checkIsInternalComponentName(name)) return false;
  if (!isCapitalized(name)) return false;
  if (name.startsWith("Primitive.")) return false;
  if (name.includes("Provider") && name.includes("Context")) return false;
  return true;
};
var getNearestComponentName = (element) => {
  if (!Ee()) return null;
  try {
    const fiber = Pe(element);
    if (!fiber) return null;
    let foundComponentName = null;
    N(
      fiber,
      (currentFiber) => {
        if (pe(currentFiber)) {
          const displayName = Te(currentFiber);
          if (displayName && checkIsSourceComponentName(displayName)) {
            foundComponentName = displayName;
            return true;
          }
        }
        return false;
      },
      true
    );
    return foundComponentName;
  } catch {
    return null;
  }
};
var getStack = async (element) => {
  if (!Ee()) return [];
  try {
    const maybeFiber = Pe(element);
    if (!maybeFiber || !me(maybeFiber)) return [];
    const fiber = De(maybeFiber);
    const unresolvedStack = [];
    N(
      fiber,
      (currentFiber) => {
        const displayName = k(currentFiber) ? typeof currentFiber.type === "string" ? currentFiber.type : null : Te(currentFiber);
        if (displayName && !checkIsInternalComponentName(displayName)) {
          unresolvedStack.push({
            name: displayName,
            sourcePromise: ke2(currentFiber)
          });
        }
      },
      true
    );
    const resolvedStack = await Promise.all(
      unresolvedStack.map(async (frame) => ({
        name: frame.name,
        source: await frame.sourcePromise
      }))
    );
    return resolvedStack.filter((frame) => frame.source !== null);
  } catch {
    return [];
  }
};
var formatStack = (stack) => {
  const isNextProject = checkIsNextProject();
  return stack.map(({ name, source }) => {
    if (!source) return `  at ${name}`;
    if (source.fileName.startsWith("about://React/Server")) {
      return `  at ${name} (Server)`;
    }
    if (!je2(source.fileName)) return `  at ${name}`;
    const framePart = `  at ${name} in ${Q(source.fileName)}`;
    if (isNextProject) {
      return `${framePart}:${source.lineNumber}:${source.columnNumber}`;
    }
    return framePart;
  }).join("\n");
};
var getHTMLPreview = (element) => {
  const tagName = element.tagName.toLowerCase();
  if (!(element instanceof HTMLElement)) {
    return `<${tagName} />`;
  }
  const text = element.innerText?.trim() ?? element.textContent?.trim() ?? "";
  let attrsText = "";
  const attributes = Array.from(element.attributes);
  for (const attribute of attributes) {
    const name = attribute.name;
    let value = attribute.value;
    if (value.length > 20) {
      value = `${value.slice(0, 20)}...`;
    }
    attrsText += ` ${name}="${value}"`;
  }
  const topElements = [];
  const bottomElements = [];
  let foundFirstText = false;
  const childNodes = Array.from(element.childNodes);
  for (const node of childNodes) {
    if (node.nodeType === Node.COMMENT_NODE) continue;
    if (node.nodeType === Node.TEXT_NODE) {
      if (node.textContent && node.textContent.trim().length > 0) {
        foundFirstText = true;
      }
    } else if (node instanceof Element) {
      if (!foundFirstText) {
        topElements.push(node);
      } else {
        bottomElements.push(node);
      }
    }
  }
  const formatElements = (elements) => {
    if (elements.length === 0) return "";
    if (elements.length <= 2) {
      return elements.map((el) => `<${el.tagName.toLowerCase()} ...>`).join("\n  ");
    }
    return `(${elements.length} elements)`;
  };
  let content = "";
  const topElementsStr = formatElements(topElements);
  if (topElementsStr) content += `
  ${topElementsStr}`;
  if (text.length > 0) {
    const truncatedText = text.length > 100 ? `${text.slice(0, 100)}...` : text;
    content += `
  ${truncatedText}`;
  }
  const bottomElementsStr = formatElements(bottomElements);
  if (bottomElementsStr) content += `
  ${bottomElementsStr}`;
  if (content.length > 0) {
    return `<${tagName}${attrsText}>${content}
</${tagName}>`;
  }
  return `<${tagName}${attrsText} />`;
};

// src/utils/copy-content.ts
var waitForFocus = () => {
  if (document.hasFocus()) {
    return new Promise((resolve) => setTimeout(resolve, 50));
  }
  return new Promise((resolve) => {
    const onFocus = () => {
      window.removeEventListener("focus", onFocus);
      setTimeout(resolve, 50);
    };
    window.addEventListener("focus", onFocus);
    window.focus();
  });
};
var copyContent = async (content, onSuccess) => {
  await waitForFocus();
  try {
    try {
      await navigator.clipboard.writeText(content);
      onSuccess?.();
      return true;
    } catch {
      const result = copyContentFallback(content, onSuccess);
      return result;
    }
  } catch {
    return false;
  }
};
var copyContentFallback = (content, onSuccess) => {
  if (!document.execCommand) return false;
  const el = document.createElement("textarea");
  el.value = String(content);
  el.style.clipPath = "inset(50%)";
  el.ariaHidden = "true";
  const doc = document.body || document.documentElement;
  doc.append(el);
  try {
    el.select();
    const result = document.execCommand("copy");
    if (result) onSuccess?.();
    return result;
  } finally {
    el.remove();
  }
};

// src/utils/is-element-visible.ts
var isElementVisible = (element, computedStyle = window.getComputedStyle(element)) => {
  return computedStyle.display !== "none" && computedStyle.visibility !== "hidden" && computedStyle.opacity !== "0";
};

// src/utils/is-valid-grabbable-element.ts
var isValidGrabbableElement = (element) => {
  if (element.closest(`[${ATTRIBUTE_NAME}]`)) {
    return false;
  }
  const computedStyle = window.getComputedStyle(element);
  if (!isElementVisible(element, computedStyle)) {
    return false;
  }
  if (computedStyle.pointerEvents === "none") {
    return false;
  }
  return true;
};

// src/utils/get-element-at-position.ts
var getElementAtPosition = (clientX, clientY) => {
  const elementsAtPoint = document.elementsFromPoint(clientX, clientY);
  for (const candidateElement of elementsAtPoint) {
    if (isValidGrabbableElement(candidateElement)) {
      return candidateElement;
    }
  }
  return null;
};

// src/utils/get-elements-in-drag.ts
var DRAG_COVERAGE_THRESHOLD = 0.75;
var calculateIntersectionArea = (rect1, rect2) => {
  const intersectionLeft = Math.max(rect1.left, rect2.left);
  const intersectionTop = Math.max(rect1.top, rect2.top);
  const intersectionRight = Math.min(rect1.right, rect2.right);
  const intersectionBottom = Math.min(rect1.bottom, rect2.bottom);
  const intersectionWidth = Math.max(0, intersectionRight - intersectionLeft);
  const intersectionHeight = Math.max(0, intersectionBottom - intersectionTop);
  return intersectionWidth * intersectionHeight;
};
var hasIntersection = (rect1, rect2) => {
  return rect1.left < rect2.right && rect1.right > rect2.left && rect1.top < rect2.bottom && rect1.bottom > rect2.top;
};
var filterElementsInDrag = (dragRect, isValidGrabbableElement2, shouldCheckCoverage) => {
  const elements = [];
  const allElements = Array.from(document.querySelectorAll("*"));
  const dragBounds = {
    left: dragRect.x,
    top: dragRect.y,
    right: dragRect.x + dragRect.width,
    bottom: dragRect.y + dragRect.height
  };
  for (const candidateElement of allElements) {
    if (!shouldCheckCoverage) {
      const tagName = (candidateElement.tagName || "").toUpperCase();
      if (tagName === "HTML" || tagName === "BODY") continue;
    }
    if (!isValidGrabbableElement2(candidateElement)) {
      continue;
    }
    const elementRect = candidateElement.getBoundingClientRect();
    const elementBounds = {
      left: elementRect.left,
      top: elementRect.top,
      right: elementRect.left + elementRect.width,
      bottom: elementRect.top + elementRect.height
    };
    if (shouldCheckCoverage) {
      const intersectionArea = calculateIntersectionArea(dragBounds, elementBounds);
      const elementArea = Math.max(0, elementRect.width * elementRect.height);
      const hasMajorityCoverage = elementArea > 0 && intersectionArea / elementArea >= DRAG_COVERAGE_THRESHOLD;
      if (hasMajorityCoverage) {
        elements.push(candidateElement);
      }
    } else {
      if (hasIntersection(elementBounds, dragBounds)) {
        elements.push(candidateElement);
      }
    }
  }
  return elements;
};
var removeNestedElements = (elements) => {
  return elements.filter((element) => {
    return !elements.some(
      (otherElement) => otherElement !== element && otherElement.contains(element)
    );
  });
};
var getElementsInDrag = (dragRect, isValidGrabbableElement2) => {
  const elements = filterElementsInDrag(dragRect, isValidGrabbableElement2, true);
  const uniqueElements = removeNestedElements(elements);
  return uniqueElements;
};
var getElementsInDragLoose = (dragRect, isValidGrabbableElement2) => {
  const elements = filterElementsInDrag(dragRect, isValidGrabbableElement2, false);
  const uniqueElements = removeNestedElements(elements);
  return uniqueElements;
};

// src/utils/strip-translate-from-transform.ts
var isValidNumber = (value) => typeof value === "number" && !Number.isNaN(value) && Number.isFinite(value);
var parseMatrixValue = (value) => {
  const trimmedValue = value.trim();
  if (!trimmedValue) return null;
  const parsedValue = parseFloat(trimmedValue);
  return isValidNumber(parsedValue) ? parsedValue : null;
};
var parseMatrixValues = (valuesString, expectedLength) => {
  const rawValues = valuesString.split(",");
  if (rawValues.length !== expectedLength) {
    return null;
  }
  const parsedValues = [];
  for (const rawValue of rawValues) {
    const parsedValue = parseMatrixValue(rawValue);
    if (parsedValue === null) {
      return null;
    }
    parsedValues.push(parsedValue);
  }
  return parsedValues;
};
var isIdentityMatrix2d = (a3, b3, c3, d3) => a3 === 1 && b3 === 0 && c3 === 0 && d3 === 1;
var isIdentityMatrix3d = (values) => values[0] === 1 && values[1] === 0 && values[2] === 0 && values[3] === 0 && values[4] === 0 && values[5] === 1 && values[6] === 0 && values[7] === 0 && values[8] === 0 && values[9] === 0 && values[10] === 1 && values[11] === 0 && values[15] === 1;
var stripTranslateFromTransform = (element) => {
  try {
    if (!(element instanceof Element)) {
      return "none";
    }
    const computedStyle = window.getComputedStyle(element);
    if (!computedStyle) {
      return "none";
    }
    const transform = computedStyle.transform;
    if (!transform || transform === "none") {
      return "none";
    }
    const matrix3dMatch = transform.match(/^matrix3d\(([^)]+)\)$/);
    if (matrix3dMatch) {
      const values = parseMatrixValues(matrix3dMatch[1], 16);
      if (values && values.length === 16) {
        const strippedValues = [...values];
        strippedValues[12] = 0;
        strippedValues[13] = 0;
        strippedValues[14] = 0;
        if (isIdentityMatrix3d(strippedValues)) {
          return "none";
        }
        return `matrix3d(${strippedValues.join(", ")})`;
      }
    }
    const matrixMatch = transform.match(/^matrix\(([^)]+)\)$/);
    if (matrixMatch) {
      const values = parseMatrixValues(matrixMatch[1], 6);
      if (values && values.length === 6) {
        const [a3, b3, c3, d3] = values;
        if (isIdentityMatrix2d(a3, b3, c3, d3)) {
          return "none";
        }
        return `matrix(${a3}, ${b3}, ${c3}, ${d3}, 0, 0)`;
      }
    }
    return "none";
  } catch {
    return "none";
  }
};

// src/utils/create-element-bounds.ts
var createElementBounds = (element) => {
  const boundingRect = element.getBoundingClientRect();
  const computedStyle = window.getComputedStyle(element);
  return {
    borderRadius: computedStyle.borderRadius || "0px",
    height: boundingRect.height,
    transform: stripTranslateFromTransform(element),
    width: boundingRect.width,
    x: boundingRect.left,
    y: boundingRect.top
  };
};

// src/theme.ts
var DEFAULT_THEME = {
  enabled: true,
  hue: 0,
  selectionBox: {
    enabled: true,
    color: void 0,
    borderRadius: void 0
  },
  dragBox: {
    enabled: true,
    color: void 0
  },
  grabbedBoxes: {
    enabled: true,
    color: void 0
  },
  elementLabel: {
    enabled: true,
    backgroundColor: void 0,
    textColor: void 0,
    borderColor: void 0,
    padding: void 0,
    cursorOffset: void 0
  },
  successLabels: {
    enabled: true
  },
  crosshair: {
    enabled: true,
    color: void 0
  },
  inputOverlay: {
    enabled: true
  }
};
var mergeTheme = (userTheme) => {
  if (!userTheme) return DEFAULT_THEME;
  return {
    enabled: userTheme.enabled ?? DEFAULT_THEME.enabled,
    hue: userTheme.hue ?? DEFAULT_THEME.hue,
    selectionBox: {
      enabled: userTheme.selectionBox?.enabled ?? DEFAULT_THEME.selectionBox.enabled,
      color: userTheme.selectionBox?.color ?? DEFAULT_THEME.selectionBox.color,
      borderRadius: userTheme.selectionBox?.borderRadius ?? DEFAULT_THEME.selectionBox.borderRadius
    },
    dragBox: {
      enabled: userTheme.dragBox?.enabled ?? DEFAULT_THEME.dragBox.enabled,
      color: userTheme.dragBox?.color ?? DEFAULT_THEME.dragBox.color
    },
    grabbedBoxes: {
      enabled: userTheme.grabbedBoxes?.enabled ?? DEFAULT_THEME.grabbedBoxes.enabled,
      color: userTheme.grabbedBoxes?.color ?? DEFAULT_THEME.grabbedBoxes.color
    },
    elementLabel: {
      enabled: userTheme.elementLabel?.enabled ?? DEFAULT_THEME.elementLabel.enabled,
      backgroundColor: userTheme.elementLabel?.backgroundColor ?? DEFAULT_THEME.elementLabel.backgroundColor,
      textColor: userTheme.elementLabel?.textColor ?? DEFAULT_THEME.elementLabel.textColor,
      borderColor: userTheme.elementLabel?.borderColor ?? DEFAULT_THEME.elementLabel.borderColor,
      padding: userTheme.elementLabel?.padding ?? DEFAULT_THEME.elementLabel.padding,
      cursorOffset: userTheme.elementLabel?.cursorOffset ?? DEFAULT_THEME.elementLabel.cursorOffset
    },
    successLabels: {
      enabled: userTheme.successLabels?.enabled ?? DEFAULT_THEME.successLabels.enabled
    },
    crosshair: {
      enabled: userTheme.crosshair?.enabled ?? DEFAULT_THEME.crosshair.enabled,
      color: userTheme.crosshair?.color ?? DEFAULT_THEME.crosshair.color
    },
    inputOverlay: {
      enabled: userTheme.inputOverlay?.enabled ?? DEFAULT_THEME.inputOverlay.enabled
    }
  };
};
var deepMergeTheme = (baseTheme, partialTheme) => {
  return {
    enabled: partialTheme.enabled ?? baseTheme.enabled,
    hue: partialTheme.hue ?? baseTheme.hue,
    selectionBox: {
      enabled: partialTheme.selectionBox?.enabled ?? baseTheme.selectionBox.enabled,
      color: partialTheme.selectionBox?.color ?? baseTheme.selectionBox.color,
      borderRadius: partialTheme.selectionBox?.borderRadius ?? baseTheme.selectionBox.borderRadius
    },
    dragBox: {
      enabled: partialTheme.dragBox?.enabled ?? baseTheme.dragBox.enabled,
      color: partialTheme.dragBox?.color ?? baseTheme.dragBox.color
    },
    grabbedBoxes: {
      enabled: partialTheme.grabbedBoxes?.enabled ?? baseTheme.grabbedBoxes.enabled,
      color: partialTheme.grabbedBoxes?.color ?? baseTheme.grabbedBoxes.color
    },
    elementLabel: {
      enabled: partialTheme.elementLabel?.enabled ?? baseTheme.elementLabel.enabled,
      backgroundColor: partialTheme.elementLabel?.backgroundColor ?? baseTheme.elementLabel.backgroundColor,
      textColor: partialTheme.elementLabel?.textColor ?? baseTheme.elementLabel.textColor,
      borderColor: partialTheme.elementLabel?.borderColor ?? baseTheme.elementLabel.borderColor,
      padding: partialTheme.elementLabel?.padding ?? baseTheme.elementLabel.padding,
      cursorOffset: partialTheme.elementLabel?.cursorOffset ?? baseTheme.elementLabel.cursorOffset
    },
    successLabels: {
      enabled: partialTheme.successLabels?.enabled ?? baseTheme.successLabels.enabled
    },
    crosshair: {
      enabled: partialTheme.crosshair?.enabled ?? baseTheme.crosshair.enabled,
      color: partialTheme.crosshair?.color ?? baseTheme.crosshair.color
    },
    inputOverlay: {
      enabled: partialTheme.inputOverlay?.enabled ?? baseTheme.inputOverlay.enabled
    }
  };
};

// src/core.tsx
var _tmpl$9 = /* @__PURE__ */ template(`<span class="font-mono tabular-nums align-middle">1 element`);
var _tmpl$23 = /* @__PURE__ */ template(`<span class="font-mono tabular-nums align-middle">&lt;<!>>`);
var _tmpl$33 = /* @__PURE__ */ template(`<span class="tabular-nums text-[10px] ml-1 align-middle"> in `);
var hasInited = false;
var init = (rawOptions) => {
  const options = {
    enabled: true,
    keyHoldDuration: 200,
    allowActivationInsideInput: true,
    ...rawOptions
  };
  const initialTheme = mergeTheme(options.theme);
  if (options.enabled === false || hasInited) {
    return {
      activate: () => {
      },
      deactivate: () => {
      },
      toggle: () => {
      },
      isActive: () => false,
      dispose: () => {
      },
      copyElement: () => Promise.resolve(false),
      getState: () => ({
        isActive: false,
        isDragging: false,
        isCopying: false,
        targetElement: null,
        dragBounds: null
      }),
      updateTheme: () => {
      },
      getTheme: () => initialTheme
    };
  }
  hasInited = true;
  const logIntro = () => {
    try {
      const version = "0.0.51";
      const logoSvg = `<svg width="294" height="294" viewBox="0 0 294 294" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_0_3)"><mask id="mask0_0_3" style="mask-type:luminance" maskUnits="userSpaceOnUse" x="0" y="0" width="294" height="294"><path d="M294 0H0V294H294V0Z" fill="white"/></mask><g mask="url(#mask0_0_3)"><path d="M144.599 47.4924C169.712 27.3959 194.548 20.0265 212.132 30.1797C227.847 39.2555 234.881 60.3243 231.926 89.516C231.677 92.0069 231.328 94.5423 230.94 97.1058L228.526 110.14C228.517 110.136 228.505 110.132 228.495 110.127C228.486 110.165 228.479 110.203 228.468 110.24L216.255 105.741C216.256 105.736 216.248 105.728 216.248 105.723C207.915 103.125 199.421 101.075 190.82 99.5888L190.696 99.5588L173.526 97.2648L173.511 97.2631C173.492 97.236 173.467 97.2176 173.447 97.1905C163.862 96.2064 154.233 95.7166 144.599 95.7223C134.943 95.7162 125.295 96.219 115.693 97.2286C110.075 105.033 104.859 113.118 100.063 121.453C95.2426 129.798 90.8624 138.391 86.939 147.193C90.8624 155.996 95.2426 164.588 100.063 172.933C104.866 181.302 110.099 189.417 115.741 197.245C115.749 197.245 115.758 197.246 115.766 197.247L115.752 197.27L115.745 197.283L115.754 197.296L126.501 211.013L126.574 211.089C132.136 217.767 138.126 224.075 144.507 229.974L144.609 230.082L154.572 238.287C154.539 238.319 154.506 238.35 154.472 238.38C154.485 238.392 154.499 238.402 154.513 238.412L143.846 247.482L143.827 247.497C126.56 261.128 109.472 268.745 94.8019 268.745C88.5916 268.837 82.4687 267.272 77.0657 264.208C61.3496 255.132 54.3164 234.062 57.2707 204.871C57.528 202.307 57.8806 199.694 58.2904 197.054C28.3363 185.327 9.52301 167.51 9.52301 147.193C9.52301 129.042 24.2476 112.396 50.9901 100.375C53.3443 99.3163 55.7938 98.3058 58.2904 97.3526C57.8806 94.7023 57.528 92.0803 57.2707 89.516C54.3164 60.3243 61.3496 39.2555 77.0657 30.1797C94.6494 20.0265 119.486 27.3959 144.599 47.4924ZM70.6423 201.315C70.423 202.955 70.2229 204.566 70.0704 206.168C67.6686 229.567 72.5478 246.628 83.3615 252.988L83.5176 253.062C95.0399 259.717 114.015 254.426 134.782 238.38C125.298 229.45 116.594 219.725 108.764 209.314C95.8516 207.742 83.0977 205.066 70.6423 201.315ZM80.3534 163.438C77.34 171.677 74.8666 180.104 72.9484 188.664C81.1787 191.224 89.5657 193.247 98.0572 194.724L98.4618 194.813C95.2115 189.865 92.0191 184.66 88.9311 179.378C85.8433 174.097 83.003 168.768 80.3534 163.438ZM60.759 110.203C59.234 110.839 57.7378 111.475 56.27 112.11C34.7788 121.806 22.3891 134.591 22.3891 147.193C22.3891 160.493 36.4657 174.297 60.7494 184.26C63.7439 171.581 67.8124 159.182 72.9104 147.193C67.822 135.23 63.7566 122.855 60.759 110.203ZM98.4137 99.6404C89.8078 101.145 81.3075 103.206 72.9676 105.809C74.854 114.203 77.2741 122.468 80.2132 130.554L80.3059 130.939C82.9938 125.6 85.8049 120.338 88.8834 115.008C91.9618 109.679 95.1544 104.569 98.4137 99.6404ZM94.9258 38.5215C90.9331 38.4284 86.9866 39.3955 83.4891 41.3243C72.6291 47.6015 67.6975 64.5954 70.0424 87.9446L70.0416 88.2194C70.194 89.8208 70.3941 91.4325 70.6134 93.0624C83.0737 89.3364 95.8263 86.6703 108.736 85.0924C116.57 74.6779 125.28 64.9532 134.773 56.0249C119.877 44.5087 105.895 38.5215 94.9258 38.5215ZM205.737 41.3148C202.268 39.398 198.355 38.4308 194.394 38.5099L194.29 38.512C183.321 38.512 169.34 44.4991 154.444 56.0153C163.93 64.9374 172.634 74.6557 180.462 85.064C193.375 86.6345 206.128 89.3102 218.584 93.0624C218.812 91.4325 219.003 89.8118 219.165 88.2098C221.548 64.7099 216.65 47.6164 205.737 41.3148ZM144.552 64.3097C138.104 70.2614 132.054 76.6306 126.443 83.3765C132.39 82.995 138.426 82.8046 144.552 82.8046C150.727 82.8046 156.778 83.0143 162.707 83.3765C157.08 76.6293 151.015 70.2596 144.552 64.3097Z" fill="white"/><path d="M144.598 47.4924C169.712 27.3959 194.547 20.0265 212.131 30.1797C227.847 39.2555 234.88 60.3243 231.926 89.516C231.677 92.0069 231.327 94.5423 230.941 97.1058L228.526 110.14L228.496 110.127C228.487 110.165 228.478 110.203 228.469 110.24L216.255 105.741L216.249 105.723C207.916 103.125 199.42 101.075 190.82 99.5888L190.696 99.5588L173.525 97.2648L173.511 97.263C173.492 97.236 173.468 97.2176 173.447 97.1905C163.863 96.2064 154.234 95.7166 144.598 95.7223C134.943 95.7162 125.295 96.219 115.693 97.2286C110.075 105.033 104.859 113.118 100.063 121.453C95.2426 129.798 90.8622 138.391 86.939 147.193C90.8622 155.996 95.2426 164.588 100.063 172.933C104.866 181.302 110.099 189.417 115.741 197.245L115.766 197.247L115.752 197.27L115.745 197.283L115.754 197.296L126.501 211.013L126.574 211.089C132.136 217.767 138.126 224.075 144.506 229.974L144.61 230.082L154.572 238.287C154.539 238.319 154.506 238.35 154.473 238.38L154.512 238.412L143.847 247.482L143.827 247.497C126.56 261.13 109.472 268.745 94.8018 268.745C88.5915 268.837 82.4687 267.272 77.0657 264.208C61.3496 255.132 54.3162 234.062 57.2707 204.871C57.528 202.307 57.8806 199.694 58.2904 197.054C28.3362 185.327 9.52298 167.51 9.52298 147.193C9.52298 129.042 24.2476 112.396 50.9901 100.375C53.3443 99.3163 55.7938 98.3058 58.2904 97.3526C57.8806 94.7023 57.528 92.0803 57.2707 89.516C54.3162 60.3243 61.3496 39.2555 77.0657 30.1797C94.6493 20.0265 119.486 27.3959 144.598 47.4924ZM70.6422 201.315C70.423 202.955 70.2229 204.566 70.0704 206.168C67.6686 229.567 72.5478 246.628 83.3615 252.988L83.5175 253.062C95.0399 259.717 114.015 254.426 134.782 238.38C125.298 229.45 116.594 219.725 108.764 209.314C95.8515 207.742 83.0977 205.066 70.6422 201.315ZM80.3534 163.438C77.34 171.677 74.8666 180.104 72.9484 188.664C81.1786 191.224 89.5657 193.247 98.0572 194.724L98.4618 194.813C95.2115 189.865 92.0191 184.66 88.931 179.378C85.8433 174.097 83.003 168.768 80.3534 163.438ZM60.7589 110.203C59.234 110.839 57.7378 111.475 56.2699 112.11C34.7788 121.806 22.3891 134.591 22.3891 147.193C22.3891 160.493 36.4657 174.297 60.7494 184.26C63.7439 171.581 67.8124 159.182 72.9103 147.193C67.822 135.23 63.7566 122.855 60.7589 110.203ZM98.4137 99.6404C89.8078 101.145 81.3075 103.206 72.9676 105.809C74.8539 114.203 77.2741 122.468 80.2132 130.554L80.3059 130.939C82.9938 125.6 85.8049 120.338 88.8834 115.008C91.9618 109.679 95.1544 104.569 98.4137 99.6404ZM94.9258 38.5215C90.9331 38.4284 86.9866 39.3955 83.4891 41.3243C72.629 47.6015 67.6975 64.5954 70.0424 87.9446L70.0415 88.2194C70.194 89.8208 70.3941 91.4325 70.6134 93.0624C83.0737 89.3364 95.8262 86.6703 108.736 85.0924C116.57 74.6779 125.28 64.9532 134.772 56.0249C119.877 44.5087 105.895 38.5215 94.9258 38.5215ZM205.737 41.3148C202.268 39.398 198.355 38.4308 194.394 38.5099L194.291 38.512C183.321 38.512 169.34 44.4991 154.443 56.0153C163.929 64.9374 172.634 74.6557 180.462 85.064C193.374 86.6345 206.129 89.3102 218.584 93.0624C218.813 91.4325 219.003 89.8118 219.166 88.2098C221.548 64.7099 216.65 47.6164 205.737 41.3148ZM144.551 64.3097C138.103 70.2614 132.055 76.6306 126.443 83.3765C132.389 82.995 138.427 82.8046 144.551 82.8046C150.727 82.8046 156.779 83.0143 162.707 83.3765C157.079 76.6293 151.015 70.2596 144.551 64.3097Z" fill="#FF40E0"/></g><mask id="mask1_0_3" style="mask-type:luminance" maskUnits="userSpaceOnUse" x="102" y="84" width="161" height="162"><path d="M235.282 84.827L102.261 112.259L129.693 245.28L262.714 217.848L235.282 84.827Z" fill="white"/></mask><g mask="url(#mask1_0_3)"><path d="M136.863 129.916L213.258 141.224C220.669 142.322 222.495 152.179 215.967 155.856L187.592 171.843L184.135 204.227C183.339 211.678 173.564 213.901 169.624 207.526L129.021 141.831C125.503 136.14 130.245 128.936 136.863 129.916Z" fill="#FF40E0" stroke="#FF40E0" stroke-width="0.817337" stroke-linecap="round" stroke-linejoin="round"/></g></g><defs><clipPath id="clip0_0_3"><rect width="294" height="294" fill="white"/></clipPath></defs></svg>`;
      const logoDataUri = `data:image/svg+xml;base64,${btoa(logoSvg)}`;
      console.log(`%cReact Grab${version ? ` v${version}` : ""}%c
https://react-grab.com`, `background: #330039; color: #ffffff; border: 1px solid #d75fcb; padding: 4px 4px 4px 24px; border-radius: 4px; background-image: url("${logoDataUri}"); background-size: 16px 16px; background-repeat: no-repeat; background-position: 4px center; display: inline-block; margin-bottom: 4px;`, "");
      if (navigator.onLine && version) {
        fetch(`https://www.react-grab.com/api/version?t=${Date.now()}`, {
          referrerPolicy: "origin",
          keepalive: true,
          priority: "low",
          cache: "no-store"
        }).then((res) => res.text()).then((latestVersion) => {
          if (latestVersion && latestVersion !== version) {
            console.warn(`[React Grab] v${version} is outdated (latest: v${latestVersion})`);
          }
        }).catch(() => null);
      }
    } catch {
    }
  };
  logIntro();
  return createRoot((dispose2) => {
    const [theme, setTheme] = createSignal(initialTheme);
    const [isHoldingKeys, setIsHoldingKeys] = createSignal(false);
    const [mouseX, setMouseX] = createSignal(OFFSCREEN_POSITION);
    const [mouseY, setMouseY] = createSignal(OFFSCREEN_POSITION);
    const [isDragging, setIsDragging] = createSignal(false);
    const [dragStartX, setDragStartX] = createSignal(OFFSCREEN_POSITION);
    const [dragStartY, setDragStartY] = createSignal(OFFSCREEN_POSITION);
    const [isCopying, setIsCopying] = createSignal(false);
    const [lastGrabbedElement, setLastGrabbedElement] = createSignal(null);
    const [progressStartTime, setProgressStartTime] = createSignal(null);
    const [progress, setProgress] = createSignal(0);
    const [grabbedBoxes, setGrabbedBoxes] = createSignal([]);
    const [successLabels, setSuccessLabels] = createSignal([]);
    const [isActivated, setIsActivated] = createSignal(false);
    const [isToggleMode, setIsToggleMode] = createSignal(false);
    const [showProgressIndicator, setShowProgressIndicator] = createSignal(false);
    const [didJustDrag, setDidJustDrag] = createSignal(false);
    const [copyStartX, setCopyStartX] = createSignal(OFFSCREEN_POSITION);
    const [copyStartY, setCopyStartY] = createSignal(OFFSCREEN_POSITION);
    const [mouseHasSettled, setMouseHasSettled] = createSignal(false);
    const [viewportVersion, setViewportVersion] = createSignal(0);
    const [isInputMode, setIsInputMode] = createSignal(false);
    const [inputText, setInputText] = createSignal("");
    let holdTimerId = null;
    let progressAnimationId = null;
    let progressDelayTimerId = null;
    let keydownSpamTimerId = null;
    let mouseSettleTimerId = null;
    let autoScrollAnimationId = null;
    const isRendererActive = createMemo(() => isActivated() && !isCopying());
    const hasValidMousePosition = createMemo(() => mouseX() > OFFSCREEN_POSITION && mouseY() > OFFSCREEN_POSITION);
    const isTargetKeyCombination = (event) => (
      // NOTE: we use event.code instead of event.key for keyboard layout compatibility (e.g., AZERTY, QWERTZ)
      (event.metaKey || event.ctrlKey) && event.code === "KeyC"
    );
    const getAutoScrollDirection = (clientX, clientY) => {
      return {
        top: clientY < AUTO_SCROLL_EDGE_THRESHOLD_PX,
        bottom: clientY > window.innerHeight - AUTO_SCROLL_EDGE_THRESHOLD_PX,
        left: clientX < AUTO_SCROLL_EDGE_THRESHOLD_PX,
        right: clientX > window.innerWidth - AUTO_SCROLL_EDGE_THRESHOLD_PX
      };
    };
    const showTemporaryGrabbedBox = (bounds, element) => {
      const boxId = `grabbed-${Date.now()}-${Math.random()}`;
      const createdAt = Date.now();
      const newBox = {
        id: boxId,
        bounds,
        createdAt,
        element
      };
      const currentBoxes = grabbedBoxes();
      setGrabbedBoxes([...currentBoxes, newBox]);
      setTimeout(() => {
        setGrabbedBoxes((previousBoxes) => previousBoxes.filter((box) => box.id !== boxId));
      }, SUCCESS_LABEL_DURATION_MS);
    };
    const showTemporarySuccessLabel = (text) => {
      const labelId = `success-${Date.now()}-${Math.random()}`;
      setSuccessLabels((previousLabels) => [...previousLabels, {
        id: labelId,
        text
      }]);
      setTimeout(() => {
        setSuccessLabels((previousLabels) => previousLabels.filter((label) => label.id !== labelId));
      }, SUCCESS_LABEL_DURATION_MS);
    };
    const wrapInSelectedElementTags = (context) => `<selected_element>
${context}
</selected_element>`;
    const extractElementTagName = (element) => (element.tagName || "").toLowerCase();
    const extractElementTagNameForSuccess = (element) => {
      const tagName = extractElementTagName(element);
      return tagName ? `<${tagName}>` : "1 element";
    };
    const notifyElementsSelected = (elements) => {
      try {
        const elementsPayload = elements.map((element) => ({
          tagName: extractElementTagName(element)
        }));
        window.dispatchEvent(new CustomEvent("react-grab:element-selected", {
          detail: {
            elements: elementsPayload
          }
        }));
      } catch {
      }
    };
    const executeCopyOperation = async (positionX, positionY, operation) => {
      setCopyStartX(positionX);
      setCopyStartY(positionY);
      setIsCopying(true);
      startProgressAnimation();
      await operation().finally(() => {
        setIsCopying(false);
        stopProgressAnimation();
        if (isToggleMode()) {
          deactivateRenderer();
        }
      });
    };
    const hasInnerText = (element) => "innerText" in element;
    const extractElementTextContent = (element) => {
      if (hasInnerText(element)) {
        return element.innerText;
      }
      return element.textContent ?? "";
    };
    const createCombinedTextContent = (elements) => elements.map((element) => extractElementTextContent(element).trim()).filter((textContent) => textContent.length > 0).join("\n\n");
    const tryCopyWithFallback = async (elements, extraPrompt) => {
      let didCopy = false;
      let copiedContent = "";
      const isReactProject = Ee();
      try {
        await options.onBeforeCopy?.(elements);
      } catch {
      }
      try {
        const elementSnippetResults = await Promise.allSettled(elements.map(async (element) => {
          const htmlPreview = getHTMLPreview(element);
          if (!isReactProject) {
            return `## HTML Frame:
${htmlPreview}`;
          }
          const stack = await getStack(element);
          const formattedStack = formatStack(stack);
          if (formattedStack) {
            return `## HTML Frame:
${htmlPreview}

## Code Location:
${formattedStack}`;
          }
          return `## HTML Frame:
${htmlPreview}`;
        }));
        const elementSnippets = elementSnippetResults.map((result) => result.status === "fulfilled" ? result.value : "").filter((snippet) => snippet.trim());
        if (elementSnippets.length > 0) {
          const wrappedSnippets = elementSnippets.map((snippet) => wrapInSelectedElementTags(snippet)).join("\n\n");
          const plainTextContent = extraPrompt ? `${extraPrompt}

${wrappedSnippets}` : wrappedSnippets;
          copiedContent = plainTextContent;
          didCopy = await copyContent(plainTextContent);
        }
        if (!didCopy) {
          const plainTextContentOnly = createCombinedTextContent(elements);
          if (plainTextContentOnly.length > 0) {
            const contentWithPrompt = extraPrompt ? `${extraPrompt}

${plainTextContentOnly}` : plainTextContentOnly;
            copiedContent = contentWithPrompt;
            didCopy = await copyContent(contentWithPrompt);
          }
        }
        if (didCopy) {
          try {
            options.onCopySuccess?.(elements, copiedContent);
          } catch {
          }
        }
      } catch (error) {
        try {
          options.onCopyError?.(error);
        } catch {
        }
        const plainTextContentOnly = createCombinedTextContent(elements);
        if (plainTextContentOnly.length > 0) {
          const contentWithPrompt = extraPrompt ? `${extraPrompt}

${plainTextContentOnly}` : plainTextContentOnly;
          copiedContent = contentWithPrompt;
          didCopy = await copyContent(contentWithPrompt);
        }
      }
      try {
        options.onAfterCopy?.(elements, didCopy);
      } catch {
      }
      return didCopy;
    };
    const copySingleElementToClipboard = async (targetElement2, extraPrompt) => {
      try {
        options.onElementSelect?.(targetElement2);
      } catch {
      }
      if (theme().grabbedBoxes.enabled) {
        showTemporaryGrabbedBox(createElementBounds(targetElement2), targetElement2);
      }
      await new Promise((resolve) => requestAnimationFrame(resolve));
      const didCopy = await tryCopyWithFallback([targetElement2], extraPrompt);
      if (didCopy && theme().successLabels.enabled) {
        showTemporarySuccessLabel(extractElementTagNameForSuccess(targetElement2));
      }
      notifyElementsSelected([targetElement2]);
    };
    const copyMultipleElementsToClipboard = async (targetElements) => {
      if (targetElements.length === 0) return;
      for (const element of targetElements) {
        try {
          options.onElementSelect?.(element);
        } catch {
        }
      }
      if (theme().grabbedBoxes.enabled) {
        for (const element of targetElements) {
          showTemporaryGrabbedBox(createElementBounds(element), element);
        }
      }
      await new Promise((resolve) => requestAnimationFrame(resolve));
      const didCopy = await tryCopyWithFallback(targetElements);
      if (didCopy && theme().successLabels.enabled) {
        showTemporarySuccessLabel(`${targetElements.length} elements`);
      }
      notifyElementsSelected(targetElements);
    };
    const targetElement = createMemo(() => {
      if (!isRendererActive() || isDragging()) return null;
      return getElementAtPosition(mouseX(), mouseY());
    });
    const selectionBounds = createMemo(() => {
      viewportVersion();
      const element = targetElement();
      if (!element) return void 0;
      const elementBounds = element.getBoundingClientRect();
      const computedStyle = window.getComputedStyle(element);
      return {
        borderRadius: computedStyle.borderRadius || "0px",
        height: elementBounds.height,
        transform: stripTranslateFromTransform(element),
        width: elementBounds.width,
        x: elementBounds.left,
        y: elementBounds.top
      };
    });
    const calculateDragDistance = (endX, endY) => {
      const endPageX = endX + window.scrollX;
      const endPageY = endY + window.scrollY;
      return {
        x: Math.abs(endPageX - dragStartX()),
        y: Math.abs(endPageY - dragStartY())
      };
    };
    const isDraggingBeyondThreshold = createMemo(() => {
      if (!isDragging()) return false;
      const dragDistance = calculateDragDistance(mouseX(), mouseY());
      return dragDistance.x > DRAG_THRESHOLD_PX || dragDistance.y > DRAG_THRESHOLD_PX;
    });
    const calculateDragRectangle = (endX, endY) => {
      const endPageX = endX + window.scrollX;
      const endPageY = endY + window.scrollY;
      const dragPageX = Math.min(dragStartX(), endPageX);
      const dragPageY = Math.min(dragStartY(), endPageY);
      const dragWidth = Math.abs(endPageX - dragStartX());
      const dragHeight = Math.abs(endPageY - dragStartY());
      return {
        x: dragPageX - window.scrollX,
        y: dragPageY - window.scrollY,
        width: dragWidth,
        height: dragHeight
      };
    };
    const dragBounds = createMemo(() => {
      if (!isDraggingBeyondThreshold()) return void 0;
      const drag = calculateDragRectangle(mouseX(), mouseY());
      return {
        borderRadius: "0px",
        height: drag.height,
        transform: "none",
        width: drag.width,
        x: drag.x,
        y: drag.y
      };
    });
    const labelContent = createMemo(() => {
      const element = targetElement();
      if (!element) return _tmpl$9();
      const tagName = extractElementTagName(element);
      const componentName = getNearestComponentName(element);
      if (tagName && componentName) {
        return [(() => {
          var _el$2 = _tmpl$23(), _el$3 = _el$2.firstChild, _el$5 = _el$3.nextSibling; _el$5.nextSibling;
          insert(_el$2, tagName, _el$5);
          return _el$2;
        })(), (() => {
          var _el$6 = _tmpl$33(); _el$6.firstChild;
          insert(_el$6, componentName, null);
          return _el$6;
        })()];
      }
      if (tagName) {
        return (() => {
          var _el$8 = _tmpl$23(), _el$9 = _el$8.firstChild, _el$1 = _el$9.nextSibling; _el$1.nextSibling;
          insert(_el$8, tagName, _el$1);
          return _el$8;
        })();
      }
      return _tmpl$9();
    });
    const labelPosition = createMemo(() => isCopying() ? {
      x: copyStartX(),
      y: copyStartY()
    } : {
      x: mouseX(),
      y: mouseY()
    });
    const progressPosition = createMemo(() => isCopying() ? {
      x: copyStartX(),
      y: copyStartY()
    } : {
      x: mouseX(),
      y: mouseY()
    });
    createEffect(on(() => [targetElement(), lastGrabbedElement()], ([currentElement, lastElement]) => {
      if (lastElement && currentElement && lastElement !== currentElement) {
        setLastGrabbedElement(null);
      }
      if (currentElement) {
        try {
          options.onElementHover?.(currentElement);
        } catch {
        }
      }
    }));
    createEffect(on(() => viewportVersion(), () => {
      const currentBoxes = grabbedBoxes();
      if (currentBoxes.length === 0) return;
      const updatedBoxes = currentBoxes.map((box) => ({
        ...box,
        bounds: createElementBounds(box.element)
      }));
      setGrabbedBoxes(updatedBoxes);
    }));
    createEffect(on(() => [isActivated(), isDragging(), isCopying(), targetElement(), dragBounds()], ([active, dragging, copying, target, drag]) => {
      try {
        options.onStateChange?.({
          isActive: active,
          isDragging: dragging,
          isCopying: copying,
          targetElement: target,
          dragBounds: drag ? {
            x: drag.x,
            y: drag.y,
            width: drag.width,
            height: drag.height
          } : null
        });
      } catch {
      }
    }));
    const startProgressAnimation = () => {
      const startTime = Date.now();
      setProgressStartTime(startTime);
      setShowProgressIndicator(false);
      progressDelayTimerId = window.setTimeout(() => {
        setShowProgressIndicator(true);
        progressDelayTimerId = null;
      }, PROGRESS_INDICATOR_DELAY_MS);
      const animateProgress = () => {
        const currentStartTime = progressStartTime();
        if (currentStartTime === null) return;
        const elapsedTime = Date.now() - currentStartTime;
        const normalizedTime = elapsedTime / options.keyHoldDuration;
        const easedProgress = 1 - Math.exp(-normalizedTime);
        const maxProgressBeforeCompletion = 0.95;
        const currentProgress = isCopying() ? Math.min(easedProgress, maxProgressBeforeCompletion) : 1;
        setProgress(currentProgress);
        if (currentProgress < 1) {
          progressAnimationId = requestAnimationFrame(animateProgress);
        }
      };
      animateProgress();
    };
    const stopProgressAnimation = () => {
      if (progressAnimationId !== null) {
        cancelAnimationFrame(progressAnimationId);
        progressAnimationId = null;
      }
      if (progressDelayTimerId !== null) {
        window.clearTimeout(progressDelayTimerId);
        progressDelayTimerId = null;
      }
      setProgressStartTime(null);
      setProgress(1);
      setShowProgressIndicator(false);
    };
    const startAutoScroll = () => {
      const scroll = () => {
        if (!isDragging()) {
          stopAutoScroll();
          return;
        }
        const direction = getAutoScrollDirection(mouseX(), mouseY());
        if (direction.top) window.scrollBy(0, -AUTO_SCROLL_SPEED_PX);
        if (direction.bottom) window.scrollBy(0, AUTO_SCROLL_SPEED_PX);
        if (direction.left) window.scrollBy(-AUTO_SCROLL_SPEED_PX, 0);
        if (direction.right) window.scrollBy(AUTO_SCROLL_SPEED_PX, 0);
        if (direction.top || direction.bottom || direction.left || direction.right) {
          autoScrollAnimationId = requestAnimationFrame(scroll);
        } else {
          autoScrollAnimationId = null;
        }
      };
      scroll();
    };
    const stopAutoScroll = () => {
      if (autoScrollAnimationId !== null) {
        cancelAnimationFrame(autoScrollAnimationId);
        autoScrollAnimationId = null;
      }
    };
    const activateRenderer = () => {
      stopProgressAnimation();
      setIsActivated(true);
      document.body.style.cursor = "crosshair";
      options.onActivate?.();
    };
    const deactivateRenderer = () => {
      setIsToggleMode(false);
      setIsHoldingKeys(false);
      setIsActivated(false);
      setIsInputMode(false);
      setInputText("");
      document.body.style.cursor = "";
      if (isDragging()) {
        setIsDragging(false);
        document.body.style.userSelect = "";
      }
      if (holdTimerId) window.clearTimeout(holdTimerId);
      if (keydownSpamTimerId) window.clearTimeout(keydownSpamTimerId);
      if (mouseSettleTimerId) {
        window.clearTimeout(mouseSettleTimerId);
        mouseSettleTimerId = null;
      }
      setMouseHasSettled(false);
      stopAutoScroll();
      stopProgressAnimation();
      options.onDeactivate?.();
    };
    const handleInputChange = (value) => {
      setInputText(value);
    };
    const handleInputSubmit = () => {
      if (!isInputMode()) return;
      const element = targetElement();
      const prompt = inputText().trim();
      const currentX = mouseX();
      const currentY = mouseY();
      setIsInputMode(false);
      setInputText("");
      if (element) {
        void executeCopyOperation(currentX, currentY, () => copySingleElementToClipboard(element, prompt || void 0)).then(() => {
          deactivateRenderer();
        });
      } else {
        deactivateRenderer();
      }
    };
    const handleInputCancel = () => {
      if (!isInputMode()) return;
      deactivateRenderer();
    };
    const abortController = new AbortController();
    const eventListenerSignal = abortController.signal;
    window.addEventListener("keydown", (event) => {
      if (event.code === "Escape" && isHoldingKeys()) {
        if (isInputMode()) {
          return;
        }
        deactivateRenderer();
        return;
      }
      if (event.code === "Enter" && isHoldingKeys() && !isInputMode()) {
        event.preventDefault();
        event.stopPropagation();
        setIsToggleMode(true);
        if (keydownSpamTimerId !== null) {
          window.clearTimeout(keydownSpamTimerId);
          keydownSpamTimerId = null;
        }
        if (!isActivated()) {
          if (holdTimerId) window.clearTimeout(holdTimerId);
          activateRenderer();
        }
        setIsInputMode(true);
        return;
      }
      if (!options.allowActivationInsideInput && isKeyboardEventTriggeredByInput(event)) {
        return;
      }
      if (!isTargetKeyCombination(event)) return;
      if (isActivated()) {
        if (isToggleMode()) return;
        if (keydownSpamTimerId !== null) {
          window.clearTimeout(keydownSpamTimerId);
        }
        keydownSpamTimerId = window.setTimeout(() => {
          deactivateRenderer();
        }, 200);
        return;
      }
      if (isHoldingKeys() && event.repeat) return;
      if (holdTimerId !== null) {
        window.clearTimeout(holdTimerId);
      }
      if (!isHoldingKeys()) {
        setIsHoldingKeys(true);
      }
      holdTimerId = window.setTimeout(() => {
        activateRenderer();
      }, options.keyHoldDuration);
    }, {
      signal: eventListenerSignal,
      capture: true
    });
    window.addEventListener("keyup", (event) => {
      if (!isHoldingKeys() && !isActivated()) return;
      const isReleasingModifier = !event.metaKey && !event.ctrlKey;
      const isReleasingC = event.code === "KeyC";
      if (isReleasingC || isReleasingModifier) {
        if (isToggleMode()) return;
        deactivateRenderer();
      }
    }, {
      signal: eventListenerSignal,
      capture: true
    });
    window.addEventListener("mousemove", (event) => {
      setMouseX(event.clientX);
      setMouseY(event.clientY);
      if (mouseSettleTimerId !== null) {
        window.clearTimeout(mouseSettleTimerId);
      }
      setMouseHasSettled(false);
      mouseSettleTimerId = window.setTimeout(() => {
        setMouseHasSettled(true);
        mouseSettleTimerId = null;
      }, 300);
      if (isDragging()) {
        const direction = getAutoScrollDirection(event.clientX, event.clientY);
        const isNearEdge = direction.top || direction.bottom || direction.left || direction.right;
        if (isNearEdge && autoScrollAnimationId === null) {
          startAutoScroll();
        } else if (!isNearEdge && autoScrollAnimationId !== null) {
          stopAutoScroll();
        }
      }
    }, {
      signal: eventListenerSignal
    });
    window.addEventListener("mousedown", (event) => {
      if (isInputMode()) {
        const target = event.target;
        const isClickingInput = target.closest("[data-react-grab-input]");
        if (!isClickingInput) {
          handleInputCancel();
        }
        return;
      }
      if (!isRendererActive() || isCopying()) return;
      event.preventDefault();
      setIsDragging(true);
      const startX = event.clientX + window.scrollX;
      const startY = event.clientY + window.scrollY;
      setDragStartX(startX);
      setDragStartY(startY);
      document.body.style.userSelect = "none";
      try {
        options.onDragStart?.(startX, startY);
      } catch {
      }
    }, {
      signal: eventListenerSignal
    });
    window.addEventListener("mouseup", (event) => {
      if (!isDragging()) return;
      const dragDistance = calculateDragDistance(event.clientX, event.clientY);
      const wasDragGesture = dragDistance.x > DRAG_THRESHOLD_PX || dragDistance.y > DRAG_THRESHOLD_PX;
      setIsDragging(false);
      stopAutoScroll();
      document.body.style.userSelect = "";
      if (wasDragGesture) {
        setDidJustDrag(true);
        const dragRect = calculateDragRectangle(event.clientX, event.clientY);
        const elements = getElementsInDrag(dragRect, isValidGrabbableElement);
        if (elements.length > 0) {
          try {
            options.onDragEnd?.(elements, dragRect);
          } catch {
          }
          void executeCopyOperation(event.clientX, event.clientY, () => copyMultipleElementsToClipboard(elements));
        } else {
          const fallbackElements = getElementsInDragLoose(dragRect, isValidGrabbableElement);
          if (fallbackElements.length > 0) {
            try {
              options.onDragEnd?.(fallbackElements, dragRect);
            } catch {
            }
            void executeCopyOperation(event.clientX, event.clientY, () => copyMultipleElementsToClipboard(fallbackElements));
          }
        }
      } else {
        const element = getElementAtPosition(event.clientX, event.clientY);
        if (!element) return;
        setLastGrabbedElement(element);
        void executeCopyOperation(event.clientX, event.clientY, () => copySingleElementToClipboard(element));
      }
    }, {
      signal: eventListenerSignal
    });
    window.addEventListener("click", (event) => {
      if (isRendererActive() || isCopying() || didJustDrag()) {
        event.preventDefault();
        event.stopPropagation();
        const hadDrag = didJustDrag();
        if (hadDrag) {
          setDidJustDrag(false);
        }
        if (isToggleMode() && !isCopying()) {
          if (!isHoldingKeys()) {
            deactivateRenderer();
          } else {
            setIsToggleMode(false);
          }
        }
      }
    }, {
      signal: eventListenerSignal,
      capture: true
    });
    document.addEventListener("visibilitychange", () => {
      if (document.hidden) {
        setGrabbedBoxes([]);
      }
    }, {
      signal: eventListenerSignal
    });
    window.addEventListener("scroll", () => {
      setViewportVersion((version) => version + 1);
    }, {
      signal: eventListenerSignal,
      capture: true
    });
    window.addEventListener("resize", () => {
      setViewportVersion((version) => version + 1);
    }, {
      signal: eventListenerSignal
    });
    onCleanup(() => {
      abortController.abort();
      if (holdTimerId) window.clearTimeout(holdTimerId);
      if (keydownSpamTimerId) window.clearTimeout(keydownSpamTimerId);
      if (mouseSettleTimerId) window.clearTimeout(mouseSettleTimerId);
      stopAutoScroll();
      stopProgressAnimation();
      document.body.style.userSelect = "";
      document.body.style.cursor = "";
    });
    const rendererRoot = mountRoot(styles_default);
    const selectionVisible = createMemo(() => theme().selectionBox.enabled && isRendererActive() && !isDragging() && Boolean(targetElement()));
    const dragVisible = createMemo(() => theme().dragBox.enabled && isRendererActive() && isDraggingBeyondThreshold());
    const labelVariant = createMemo(() => isCopying() ? "processing" : "hover");
    const labelVisible = createMemo(() => {
      if (!theme().elementLabel.enabled) return false;
      if (isInputMode()) return false;
      if (isCopying()) return true;
      if (successLabels().length > 0) return false;
      return isRendererActive() && !isDragging() && Boolean(targetElement());
    });
    const progressVisible = createMemo(() => isCopying() && showProgressIndicator() && hasValidMousePosition());
    const crosshairVisible = createMemo(() => theme().crosshair.enabled && isRendererActive() && !isDragging());
    const inputVisible = createMemo(() => theme().inputOverlay.enabled && isInputMode());
    const shouldShowGrabbedBoxes = createMemo(() => theme().grabbedBoxes.enabled);
    const shouldShowSuccessLabels = createMemo(() => theme().successLabels.enabled);
    createEffect(on(theme, (currentTheme) => {
      if (currentTheme.hue !== 0) {
        rendererRoot.style.filter = `hue-rotate(${currentTheme.hue}deg)`;
      } else {
        rendererRoot.style.filter = "";
      }
    }));
    if (theme().enabled) {
      render(() => createComponent(ReactGrabRenderer, {
        get selectionVisible() {
          return selectionVisible();
        },
        get selectionBounds() {
          return selectionBounds();
        },
        get dragVisible() {
          return dragVisible();
        },
        get dragBounds() {
          return dragBounds();
        },
        get grabbedBoxes() {
          return memo(() => !!shouldShowGrabbedBoxes())() ? grabbedBoxes() : [];
        },
        get successLabels() {
          return memo(() => !!shouldShowSuccessLabels())() ? successLabels() : [];
        },
        get labelVariant() {
          return labelVariant();
        },
        get labelContent() {
          return labelContent();
        },
        get labelX() {
          return labelPosition().x;
        },
        get labelY() {
          return labelPosition().y;
        },
        get labelVisible() {
          return labelVisible();
        },
        labelZIndex: Z_INDEX_LABEL,
        get labelShowHint() {
          return mouseHasSettled();
        },
        get progressVisible() {
          return progressVisible();
        },
        get progress() {
          return progress();
        },
        get mouseX() {
          return progressPosition().x;
        },
        get mouseY() {
          return progressPosition().y;
        },
        get crosshairVisible() {
          return crosshairVisible();
        },
        get inputVisible() {
          return inputVisible();
        },
        get inputX() {
          return mouseX();
        },
        get inputY() {
          return mouseY();
        },
        get inputValue() {
          return inputText();
        },
        onInputChange: handleInputChange,
        onInputSubmit: handleInputSubmit,
        onInputCancel: handleInputCancel,
        get theme() {
          return theme();
        }
      }), rendererRoot);
    }
    const copyElementAPI = async (elements) => {
      const elementsArray = Array.isArray(elements) ? elements : [elements];
      if (elementsArray.length === 0) return false;
      try {
        await options.onBeforeCopy?.(elementsArray);
      } catch {
      }
      const didCopy = await tryCopyWithFallback(elementsArray);
      try {
        options.onAfterCopy?.(elementsArray, didCopy);
      } catch {
      }
      return didCopy;
    };
    const getStateAPI = () => ({
      isActive: isActivated(),
      isDragging: isDragging(),
      isCopying: isCopying(),
      targetElement: targetElement(),
      dragBounds: dragBounds() ? {
        x: dragBounds().x,
        y: dragBounds().y,
        width: dragBounds().width,
        height: dragBounds().height
      } : null
    });
    return {
      activate: () => {
        if (!isActivated()) {
          activateRenderer();
        }
      },
      deactivate: () => {
        if (isActivated()) {
          deactivateRenderer();
        }
      },
      toggle: () => {
        if (isActivated()) {
          deactivateRenderer();
        } else {
          activateRenderer();
        }
      },
      isActive: () => isActivated(),
      dispose: dispose2,
      copyElement: copyElementAPI,
      getState: getStateAPI,
      updateTheme: (partialTheme) => {
        const currentTheme = theme();
        const mergedTheme = deepMergeTheme(currentTheme, partialTheme);
        setTheme(mergedTheme);
      },
      getTheme: () => theme()
    };
  });
};
/*! Bundled license information:

bippy/dist/rdt-hook-CrcWl4lP.js:
  (**
   * @license bippy
   *
   * Copyright (c) Aiden Bai
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

bippy/dist/install-hook-only-DtUPvEBg.js:
  (**
   * @license bippy
   *
   * Copyright (c) Aiden Bai
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

bippy/dist/core-D7_ABaNC.js:
  (**
   * @license bippy
   *
   * Copyright (c) Aiden Bai
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

bippy/dist/src-C_DvVIY-.js:
  (**
   * @license bippy
   *
   * Copyright (c) Aiden Bai
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

bippy/dist/index.js:
  (**
   * @license bippy
   *
   * Copyright (c) Aiden Bai
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

bippy/dist/source.js:
  (**
   * @license bippy
   *
   * Copyright (c) Aiden Bai
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/

exports.DEFAULT_THEME = DEFAULT_THEME;
exports.Ee = Ee;
exports.formatStack = formatStack;
exports.getHTMLPreview = getHTMLPreview;
exports.getNearestComponentName = getNearestComponentName;
exports.getStack = getStack;
exports.init = init;
